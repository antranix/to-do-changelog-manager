{"version":3,"file":"extension.js","mappings":"k3BAOA,uBAAOA,iBACL,MAAMC,EAAoB,GACpBC,EAAO,IAAIC,IAEXC,QAAcC,EAAOC,UAAUC,UACnC,0CACA,sBAGF,IAAK,MAAMC,KAAQJ,EAAO,CACxB,MAAMK,QAAYJ,EAAOC,UAAUI,iBAAiBF,GAC9CG,EAAKN,EAAOC,UAAUM,mBAAmBJ,GACzCK,EAAOF,GAAIG,IAAIC,OAErB,IAAK,IAAIC,EAAI,EAAGA,EAAIP,EAAIQ,UAAWD,IAAK,CACtC,MAAME,EAAOT,EAAIU,OAAOH,GAAGE,KAC3B,IAAKE,EAAWC,KAAKH,GAAO,SAE5B,MAAMI,EAAQJ,EAAKI,MAAM,2BACnBC,EAAMD,EAAQA,EAAM,GAAGE,OAAS,GAEhCC,EAAMZ,EAAOa,EAAKC,SAASd,EAAML,EAAKO,QAAUP,EAAKO,OAErDa,GAAO,IAAAC,iBAAgBN,EAAKE,EAAKT,GAEnCd,EAAK4B,IAAIF,EAAKG,MAClB7B,EAAK8B,IAAIJ,EAAKG,IAEd9B,EAAMgC,KAAKL,GACb,CACF,CAEA,OAAO3B,CACT,EAxCA,kBACA,YAEA,SAEMmB,EAAa,kB,01BCuBnB,gBAAOpB,iBACL,MAAMc,EAAMoB,IACZ,IAAKpB,EAAK,MAAO,GAEjB,IACE,MAAMqB,QAAc9B,EAAOC,UAAU8B,GAAGC,SAASvB,GAEjD,OA+FJ,SAAiBwB,GACf,MAAMC,EAAQD,EAAGE,MAAM,SACjBC,EAA+B,GAErC,IAAIC,EAAmC,KACnCC,EAAyB,KAE7B,IAAK,MAAMC,KAAWL,EAAO,CAC3B,MAAMM,EAAOD,EAAQpB,OACrB,IAAKqB,EAAM,SAGX,MAAMC,EAAMC,EAAoBF,GAChC,GAAIC,EAAK,CACPJ,EAAU,CACRM,QAASF,EAAIE,QACbC,KAAMH,EAAIG,KACVC,SAAUC,KAEZR,EAAU,KACVF,EAASR,KAAKS,GACd,QACF,CAEA,IAAKA,EAAS,SAGd,MAAMU,EAAUC,EAAwBR,GACxC,GAAIO,EAEGV,EAAQQ,SAASE,KAAUV,EAAQQ,SAASE,GAAW,IAC5DT,EAAUS,OAKZ,GAAIT,GAAWE,EAAKS,WAAW,MAAO,CACpC,MAAMpC,EAAOqC,EAAWV,GACxB,IAAK3B,EAAM,SAEXwB,EAAQQ,SAASP,GAASV,KAAK,CAAEf,QACnC,CACF,CAEA,OAAOuB,CACT,CA5IWe,CADIC,EAAQC,OAAOvB,GAE5B,CAAE,MAEA,MAAO,EACT,CACF,EAEA,iBAAOnC,eACLyC,GAEA,MAAM3B,EAAMoB,IACZ,IAAKpB,EAAK,OAEV,MAAMwB,EAiIR,SAAoBG,GAClB,MAAMF,EAAkB,GAElBoB,EAAe,CACnB,YACA,UACA,eACA,QACA,WACA,oBAGIC,EAAS,IAAInB,GAAUoB,KAAK,CAACC,EAAGC,KACpC,MAAMC,EAASD,EAAEd,KAAKgB,cAAcH,EAAEb,MACtC,OAAe,IAAXe,EAAqBA,EAElBE,OAAOH,EAAEf,SAASiB,cAAcC,OAAOJ,EAAEd,cAAUmB,EAAW,CACnEC,SAAS,MAIb,IAAK,MAAMC,KAAKT,EAAQ,CACtB,MAAMU,EAAsBX,EAAaY,OACtCC,IAASH,EAAEnB,WAAWsB,IAAMC,QAAU,GAAK,GAG9ClC,EAAMN,KAAK,MAAMoC,EAAErB,WAAWqB,EAAEpB,QAEhC,IAAK,MAAMG,KAAWkB,EAAqB,CACzC/B,EAAMN,KAAK,IACXM,EAAMN,KAAK,OAAOmB,KAElB,MAAMsB,EAAUL,EAAEnB,SAASE,GAC3B,IAAK,MAAMuB,KAAKD,EACdnC,EAAMN,KAAK,KAAK0C,EAAEzD,OAEtB,CAEAqB,EAAMN,KAAK,GACb,CAEA,OAAOM,EAAMqC,KAAK,KACpB,CA3KaC,CAAWpC,SAGhBpC,EAAOC,UAAU8B,GAAG0C,UAAUhE,EAAKiE,EAAQC,OAAO1C,IAGxD,MAAM2C,EAAWnE,EAAIY,KAAKc,MAAM,KAAK0C,OAAS,SAIhDlF,eAAuCiF,GACrC,MAAME,EAAU9E,EAAOC,UAAU8E,iBACjC,IAAKD,GAA8B,IAAnBA,EAAQV,OACtB,OAGF,MAAMY,EAAUF,EAAQ,GAAGrE,IACrBwE,EAAejF,EAAOkF,IAAIC,SAASH,EAAS,cAElD,IAAII,EAAU,GACd,IACE,MAAMtD,QAAc9B,EAAOC,UAAU8B,GAAGC,SAASiD,GACjDG,EAAUC,OAAOC,KAAKxD,GAAOyD,SAAS,OACxC,CAAE,MAEF,CAGA,GAAIH,EAAQjD,MAAM,SAASqD,SAASZ,GAClC,OAIF,MAAMa,EACJL,GAAWA,EAAQhB,OAAS,EAAI,KAAO,IAAMQ,EAAW,WACpD5E,EAAOC,UAAU8B,GAAG0C,UACxBQ,EACAI,OAAOC,KAAKG,EAAY,QAE5B,CAhCQC,CAAwBd,EAChC,EAxDA,kBAKMe,EAAgB,CACpB,YACA,UACA,eACA,QACA,WACA,oBAKF,SAAS9D,IACP,MAAMiD,EAAU9E,EAAOC,UAAU8E,iBACjC,OAAKD,GAA8B,IAAnBA,EAAQV,OAIjBpE,EAAOkF,IAAIC,SAASL,EAAQ,GAAGrE,IAnBtB,iBAgBdT,EAAO4F,OAAOC,mBAAmB,uCAC1B,KAGX,CAEA,MAAMzC,EAAU,IAAI0C,YAAY,SAC1BpB,EAAU,IAAIqB,YAiEpB,SAASjD,IACP,MAAMkD,EAAwC,CAAC,EAC/C,IAAK,MAAMC,KAAMN,EAAeK,EAAIC,GAAM,GAC1C,OAAOD,CACT,CAEA,SAAShD,EAAwBR,GAE/B,MAAM0D,EAAI1D,EAAKvB,MAAM,mBACrB,OAAKiF,EACEA,EAAE,GAAG/E,OADG,IAEjB,CAEA,SAASuB,EACPF,GAMA,MAAM0D,EAAI1D,EAAKvB,MACb,gEAEF,IAAKiF,EAAG,OAAO,KACf,MAAMvD,GAAWuD,EAAE,IAAMA,EAAE,KAAK/E,OAC1ByB,EAAOsD,EAAE,IAAI/E,OACnB,OAAKwB,GAAYC,EACV,CAAED,UAASC,QADY,IAEhC,CAEA,SAASM,EAAWV,GAIlB,MAAM0D,EAAI1D,EAAKvB,MAAM,iCACrB,OAAKiF,EACEA,EAAE,GAAG/E,OADG,IAEjB,C,SChIAgF,EAAOC,QAAUC,QAAQ,S,q3BCAzB,kBAEA,SAUMxD,EAAsD,CAC1D,CAAEyD,IAAK,YAAaC,MAAO,gBAC3B,CAAED,IAAK,UAAWC,MAAO,cACzB,CAAED,IAAK,eAAgBC,MAAO,mBAC9B,CAAED,IAAK,QAASC,MAAO,YACvB,CAAED,IAAK,WAAYC,MAAO,gBAC1B,CAAED,IAAK,mBAAoBC,MAAO,yBA2BpC,0BACUC,aAAe,IAAIxG,EAAOyG,aACzBC,oBAAsBC,KAAKH,aAAaI,MAEzCxE,SAA0B,GAElC,WAAAyE,GACOF,KAAKG,MACZ,CAEA,UAAMA,GACJ,MAAM5F,QAAY,IAAA6F,iBAElBJ,KAAKvE,SAAWlB,EAAI8F,IAAKhD,IAAM,CAC7BiD,KAAM,UACNtE,QAASqB,EAAErB,QACXC,KAAMoB,EAAEpB,KACRC,SAAUmB,EAAEnB,YAGd8D,KAAKH,aAAaU,MACpB,CAEA,OAAAC,GACOR,KAAKG,MACZ,CAEA,WAAAM,CAAYC,GACV,GAAqB,YAAjBA,EAAQJ,KAAoB,CAC9B,MAAMV,EAAQ,GAAGc,EAAQ1E,aAAa0E,EAAQzE,OACxC0E,EAAK,IAAItH,EAAOuH,SAAShB,EAAOvG,EAAOwH,yBAAyBC,WAEtE,OADAH,EAAGI,aAAe,mBACXJ,CACT,CAEA,GAAqB,YAAjBD,EAAQJ,KAAoB,CAC9B,MAAMK,EAAK,IAAItH,EAAOuH,SACpB,GAAGF,EAAQd,UAAUc,EAAQM,SAC7B3H,EAAOwH,yBAAyBC,WAGlC,OADAH,EAAGI,aAAe,mBACXJ,CACT,CAGA,MAAMA,EAAK,IAAItH,EAAOuH,SAAS,MAAMF,EAAQxG,OAAQb,EAAOwH,yBAAyBI,MAErF,OADAN,EAAGI,aAAe,iBACXJ,CACT,CAEA,WAAAO,CAAYR,GACV,IAAKA,EACH,OAAOS,QAAQC,QACb,IAAIpB,KAAKvE,UAAUoB,KAAK,CAACC,EAAGC,IAAMA,EAAEd,KAAKgB,cAAcH,EAAEb,QAI7D,GAAqB,YAAjByE,EAAQJ,KACV,OAAOa,QAAQC,QACblF,EAASmE,IAAI,EAAGV,MAAKC,YAGO,CACxBU,KAAM,UACNX,MACAC,QACAoB,MANYN,EAAQxE,SAASyD,IAAMlC,QAAU,EAO7CzB,QAAS0E,MASjB,GAAqB,YAAjBA,EAAQJ,KAAoB,CAC9B,MAAMxE,EAAM4E,EAAQ1E,QACdqF,EAAOvF,EAAII,SAASwE,EAAQf,MAAQ,GAE1C,OAAOwB,QAAQC,QACbC,EAAKhB,IAAK1C,IAAM,CACd2C,KAAM,QACNpG,KAAMyD,EAAEzD,KACR8B,QAASF,EACTH,QAAS+E,EAAQf,OAGvB,CAEA,OAAOwB,QAAQC,QAAQ,GACzB,E,01BC7HF,wBAA6BE,GAC3B,MAAMC,EAAW,IAAI,EAAAC,aACrBnI,EAAO4F,OAAOwC,yBAAyB,WAAYF,GAEnDD,EAAQI,cAAczG,KAEpB5B,EAAOsI,SAASC,gBAAgB,WAAY5I,UAC1C,MAAMkB,QAAab,EAAO4F,OAAO4C,aAAa,CAC5CC,OAAQ,mBAEN5H,SACIqH,EAASvG,IAAId,EAAKM,UAK5BnB,EAAOsI,SAASC,gBACd,gBACCG,GAAoBA,GAAQR,EAASS,SAASD,IAIjD1I,EAAOsI,SAASC,gBACd,kBACCG,GAAoBA,GAAQR,EAASU,WAAWF,IAInD1I,EAAOsI,SAASC,gBAAgB,eAAgB,KAC9CL,EAASf,YAIXnH,EAAOsI,SAASC,gBACd,YACA5I,MAAO+I,IACL,IAAKA,EAAM,OAEX,MAAM7H,QAAab,EAAO4F,OAAO4C,aAAa,CAC5CC,OAAQ,YACRI,MAAOH,EAAK7H,OAGVA,SACIqH,EAASY,KAAKJ,EAAM7H,EAAKM,UAMrCnB,EAAOsI,SAASC,gBACd,cACA5I,MAAO+I,IACAA,SACCR,EAASa,OAAOL,KAK1B1I,EAAOsI,SAASC,gBAAgB,iBAAkB5I,UAChD,IAEE,MAAMqJ,QAAc,IAAAC,wBAEpB,GAAqB,IAAjBD,EAAM5E,OAIR,YAHApE,EAAO4F,OAAOsD,uBACZ,oCAMJ,MAGMC,EAAW,UAHM,IAAAC,gBAGWJ,SAG5B,IAAAK,YAAWF,GAGjBjB,EAASf,UAETnH,EAAO4F,OAAOsD,uBACZ,SAASF,EAAM5E,uCAEnB,CAAE,MAAOkF,GACPC,QAAQC,MAAM,wBAAyBF,GACvCtJ,EAAO4F,OAAO6D,iBACZ,yCAEJ,IAGN,EAzGA,kBAGA,SAGA,SAGA,Q,g3BCTA,kBAEA,SAEA,qBACUjD,aAAe,IAAIxG,EAAOyG,aACzBC,oBAAsBC,KAAKH,aAAaI,MAEzC8C,MAAoB,GAE5B,WAAA7C,GACOF,KAAKG,MACZ,CAEA,UAAMA,GACJ,MAAM6C,QAAY,IAAAP,aAElBzC,KAAK+C,MAAQ,IACRC,EAAIzF,OAAQ0F,IAAOA,EAAEC,cACrBF,EAAIzF,OAAQ0F,GAAMA,EAAEC,YAGzBlD,KAAKH,aAAaU,MACpB,CAEA,OAAAC,GACOR,KAAKG,MACZ,CAEA,WAAAM,CAAYsB,GACV,MAAMnC,EAAQ,GAAGmC,EAAK7H,OAChBiJ,EAAW,IAAI9J,EAAOuH,SAAShB,GAErC,GAAImC,EAAKqB,cAAqC,iBAAdrB,EAAKlG,KAAmB,CACtD,MAAMhC,EAAOR,EAAOC,UAAU8E,mBAAmB,GACjD,GAAIvE,EAAM,CACR,MAAMC,EAAMT,EAAOkF,IAAIC,SAAS3E,EAAKC,IAAKiI,EAAKqB,cAC/CD,EAASE,QAAU,CACjBA,QAAS,cACTC,MAAO,OACPC,UAAW,CACTzJ,EACA,CAAE0J,UAAW,IAAInK,EAAOoK,MAAM1B,EAAKlG,KAAM,EAAGkG,EAAKlG,KAAM,MAG3DsH,EAASO,YAAc,GAAG3B,EAAKqB,gBAAgBrB,EAAKlG,KAAO,GAC7D,CACF,CAGA,OADAsH,EAASpC,aAAegB,EAAKmB,UAAY,OAAS,UAC3CC,CACT,CAEA,WAAAjC,GACE,OAAOC,QAAQC,QAAQpB,KAAK+C,MAC9B,CAEA,SAAM/H,CAAId,GACR,MAAMjB,QAAc,IAAAwJ,aACpBxJ,EAAMgC,MAAK,IAAA0I,UAASzJ,UACd,IAAAwI,YAAWzJ,GACjB+G,KAAKQ,SACP,CAEA,gBAAMoD,CAAWvB,GACf,GAAqB,IAAjBA,EAAM5E,OAAc,OAExB,MAAMoG,QAAiB,IAAApB,aACjBpC,EAAM,IAAIyD,IAEhB,IAAK,MAAMb,KAAKY,EAAUxD,EAAI0D,IAAId,EAAElI,GAAIkI,GACxC,IAAK,MAAMA,KAAKZ,EAAYhC,EAAIvF,IAAImI,EAAElI,KAAKsF,EAAI0D,IAAId,EAAElI,GAAIkI,SAEnD,IAAAP,YAAW,IAAIrC,EAAI2D,WACzBhE,KAAKQ,SACP,CAEA,UAAM2B,CAAKJ,EAAgBkC,GACzB,MAAMhL,QAAc,IAAAwJ,aACd7H,EAAO3B,EAAMiL,KAAMjB,GAAMA,EAAElI,KAAOgH,EAAKhH,IACxCH,IAELA,EAAKV,KAAO+J,QACN,IAAAvB,YAAWzJ,GACjB+G,KAAKQ,UACP,CAGA,gBAAMyB,CAAWF,GACf,IAAKA,EAAM,OAEX,MAAM9I,QAAc,IAAAwJ,aACd7H,EAAO3B,EAAMiL,KAAMjB,GAAMA,EAAElI,KAAOgH,EAAKhH,IACxCH,IAELA,EAAKsI,WAAY,EACjBtI,EAAKuJ,cAAgB,WAEf,IAAAzB,YAAWzJ,GACjB+G,KAAKQ,UACP,CAEA,cAAMwB,CAASD,GACb,MAAM9I,QAAc,IAAAwJ,aACdQ,EAAIhK,EAAMiL,KAAME,GAAMA,EAAErJ,KAAOgH,EAAKhH,IACrCkI,IAELA,EAAEC,WAAY,EACdD,EAAEkB,eAAgB,IAAIE,MAAOC,oBACvB,IAAA5B,YAAWzJ,GACjB+G,KAAKQ,UACP,CAEA,YAAM4B,CAAOL,SACL,IAAAW,mBAAkB,IAAAD,cAAalF,OAAQ0F,GAAMA,EAAElI,KAAOgH,EAAKhH,KACjEiF,KAAKQ,SACP,E,01BChHF,6BAAkCc,GAChC,MAAMC,EAAW,IAAI,EAAAgD,kBAEfC,EAAUnL,EAAO4F,OAAOwC,yBAAyB,gBAAiBF,GACxED,EAAQI,cAAczG,KAAKuJ,GAE3BlD,EAAQI,cAAczG,KACpB5B,EAAOsI,SAASC,gBAAgB,oBAAqB,KACnDL,EAASf,aAIbc,EAAQI,cAAczG,KACpB5B,EAAOsI,SAASC,gBAAgB,uBAAwB5I,UACtD,MAAMgD,QAAgB3C,EAAO4F,OAAO4C,aAAa,CAC/CC,OAAQ,8BAEV,IAAK9F,EAAS,OAEd,MAAMC,GAAO,IAAIoI,MAAOC,cAAc9I,MAAM,KAAK,GAC3CwH,QAAY,IAAA5C,iBAEH4C,EAAIyB,KAAMpH,GAAMA,EAAErB,UAAYA,GAE3C3C,EAAO4F,OAAOC,mBAAmB,YAAYlD,uBAI/CgH,EAAI0B,QAAQ,CACV1I,UACAC,OACAC,SAAU,CACRyI,UAAW,GACXC,QAAS,GACTC,aAAc,GACdC,MAAO,GACPC,SAAU,GACV,mBAAoB,YAIlB,IAAAC,gBAAehC,GACrBzB,EAASf,cAIbc,EAAQI,cAAczG,KACpB5B,EAAOsI,SAASC,gBAAgB,qBAAsB5I,MAAOiM,IAC3D,MAAMC,EAAaD,EAAKjJ,QAElBmJ,EAAqBF,EAAKtF,KAAOsF,EAAKG,KACtCC,EAAuBJ,EAAKrF,OAASqF,EAAKG,MAAQD,EAElDjL,QAAab,EAAO4F,OAAO4C,aAAa,CAC5CC,OAAQ,gBAAgBuD,IACxBC,YAAa,2BAEf,IAAKpL,EAAM,OAEX,MAAM8I,QAAY,IAAA5C,iBACZmF,EAAavC,EAAIwC,UAAWnI,GAAMA,EAAErB,UAAYkJ,EAAWlJ,UAC7C,IAAhBuJ,IAECvC,EAAIuC,GAAYrJ,SAASiJ,KAC5BnC,EAAIuC,GAAYrJ,SAASiJ,GAAc,IAGzCnC,EAAIuC,GAAYrJ,SAASiJ,GAAYlK,KAAK,CAAEf,eAEtC,IAAA8K,gBAAehC,GACrBzB,EAASf,cAIbc,EAAQI,cAAczG,KACpB5B,EAAOsI,SAASC,gBAAgB,sBAAuB5I,MAAOiM,IAC5D,MAAMhB,QAAgB5K,EAAO4F,OAAO4C,aAAa,CAC/CC,OAAQ,kBACRI,MAAO+C,EAAK/K,OAEd,IAAK+J,EAAS,OAEd,MAAMjB,QAAY,IAAA5C,iBACZmF,EAAavC,EAAIwC,UAAWnI,GAAMA,EAAErB,UAAYiJ,EAAKjJ,QAAQA,SACnE,IAAoB,IAAhBuJ,EAAmB,OAEvB,MAAME,EAASzC,EAAIuC,GAAYrJ,SAAS+I,EAAKtJ,UAAY,GACzDqH,EAAIuC,GAAYrJ,SAAS+I,EAAKtJ,SAAW8J,EAEzC,MAAMC,EAAWD,EAAOD,UAAW7H,GAAWA,EAAEzD,OAAS+K,EAAK/K,OAC5C,IAAdwL,IAEJD,EAAOC,GAAUxL,KAAO+J,QAElB,IAAAe,gBAAehC,GACrBzB,EAASf,cAIbc,EAAQI,cAAczG,KACpB5B,EAAOsI,SAASC,gBAAgB,wBAAyB5I,MAAOiM,IAM9D,GAAgB,cALM5L,EAAO4F,OAAOC,mBAClC,wBAAwB+F,EAAK/K,QAC7B,CAAEyL,OAAO,GACT,OAEqB,OAEvB,MAAM3C,QAAY,IAAA5C,iBACZmF,EAAavC,EAAIwC,UAAWnI,GAAMA,EAAErB,UAAYiJ,EAAKjJ,QAAQA,SACnE,IAAoB,IAAhBuJ,EAAmB,OAEvB,MAAME,EAASzC,EAAIuC,GAAYrJ,SAAS+I,EAAKtJ,UAAY,GACzDqH,EAAIuC,GAAYrJ,SAAS+I,EAAKtJ,SAAW8J,EAAOlI,OAAQI,GAAWA,EAAEzD,OAAS+K,EAAK/K,YAE7E,IAAA8K,gBAAehC,GACrBzB,EAASf,aAIbc,EAAQI,cAAczG,KACpB5B,EAAOsI,SAASC,gBAAgB,0BAA2B5I,MAAOiM,IAMhE,GAAgB,cALM5L,EAAO4F,OAAOC,mBAClC,mBAAmB+F,EAAKjJ,gCACxB,CAAE2J,OAAO,GACT,OAEqB,OAEvB,MACMC,SADY,IAAAxF,kBACG7C,OAAQF,GAAMA,EAAErB,UAAYiJ,EAAKjJ,eAEhD,IAAAgJ,gBAAeY,GACrBrE,EAASf,YAGf,EA5IA,kBACA,SACA,Q,SCFAhB,EAAOC,QAAUC,QAAQ,O,01BCuCzB,oBAAyBxF,GACvB,MAAO,CACLa,GAAI8K,EAAOC,aACX5L,OACAgJ,WAAW,EACX6C,YAAY,IAAI1B,MAAOC,cACvBH,cAAe,KAEnB,EAGA,2BACEjK,EACAkJ,EACAvH,GAEA,MAAMmK,EAAY9L,EAAKM,QAAU,OAC3ByL,EAjCR,SACE7C,EACAvH,EACA3B,GAEA,MAAM+I,EAAI/I,EAAKM,OAAO0L,MAAM,EAAG,IAC/B,MAAO,GAAGC,EAAc/C,MAAiBvH,KAAQoH,GACnD,CA0BoBmD,CAAchD,EAAcvH,EAAMmK,GAGpD,MAAO,CACLjL,IA5BYsL,EAyBIJ,EAxBXJ,EAAOS,WAAW,UAAUC,OAAOF,GAAOG,OAAO,OAAON,MAAM,EAAG,KA4BtEhM,KAAM8L,EACN9C,WAAW,EACX6C,YAAY,IAAI1B,MAAOC,cACvBH,cAAe,KACff,aAAc+C,EAAc/C,GAC5BvH,OACAoK,aAnCJ,IAAgBI,CAqChB,EAIA,YAAOrN,iBACL,MAAMc,EAAMoB,IACZ,IAAKpB,EAAK,MAAO,GAEjB,IACE,MAAMqB,QAAc9B,EAAOC,UAAU8B,GAAGC,SAASvB,GACjD,OA0BJ,SAAuBwB,GACrB,MAAMrC,EAAoB,GAE1B,IAAK,MAAM4C,KAAQP,EAAGE,MAAM,SAAU,CACpC,MAAM+D,EAAI1D,EAAKvB,MAAM,0CACrB,IAAKiF,EAAG,SAER,MAAM2D,EAAqB,MAAT3D,EAAE,GACdrF,EAAOqF,EAAE,GACTkH,EAAUlH,EAAE,GAElB,GAAKkH,EAEL,IACE,MAAMC,EAAOC,KAAKC,MAAMH,GAExBxN,EAAMgC,KAAK,CACTF,GAAI2L,EAAK3L,GACTb,OACAgJ,YACA6C,WAAYW,EAAKX,WACjB5B,cAAeuC,EAAKvC,eAAiB,KACrCf,aAAcsD,EAAKtD,aACnBvH,KAAM6K,EAAK7K,KACXoK,UAAWS,EAAKT,WAEpB,CAAE,MAEF,CACF,CAEA,OAAOhN,CACT,CA1DW4N,CAAcnI,OAAOC,KAAKxD,GAAOyD,SAAS,QACnD,CAAE,MACA,MAAO,EACT,CACF,EAIA,aAAO5F,eAA0B+J,GAC/B,MAAMjJ,EAAMoB,IACZ,IAAKpB,EAAK,OAGV,MAAMuG,EAAM,IAAIyD,IAChB,IAAK,MAAMb,KAAKF,EACT1C,EAAIvF,IAAImI,EAAElI,KAAKsF,EAAI0D,IAAId,EAAElI,GAAIkI,GAGpC,MAAM3H,EA4CR,SAA0ByH,GACxB,MAAMxH,EAAkB,CAAC,UAAW,IAEpC,IAAK,MAAMwG,KAAQgB,EAAO,CACxB,MAAM2D,EAAO,CACX3L,GAAIgH,EAAKhH,GACTgL,WAAYhE,EAAKgE,WACjB5B,cAAepC,EAAKoC,eAAiB,KACrCf,aAAcrB,EAAKqB,aACnBvH,KAAMkG,EAAKlG,KACXoK,UAAWlE,EAAKkE,WAGlB1K,EAAMN,KACJ,MAAM8G,EAAKmB,UAAY,IAAM,QAAQnB,EAAK7H,gBAAayM,KAAKG,UAC1DJ,YAGN,CAGA,OADAnL,EAAMN,KAAK,IACJM,EAAMqC,KAAK,KACpB,CAlEamJ,CAAiB,IAAI1G,EAAI2D,iBAC9B3K,EAAOC,UAAU8B,GAAG0C,UAAUhE,EAAK4E,OAAOC,KAAKrD,EAAI,eAqE3DtC,eAAuCiF,GACrC,MAAME,EAAU9E,EAAOC,UAAU8E,iBACjC,IAAKD,GAA8B,IAAnBA,EAAQV,OAAc,OAEtC,MAAMa,EAAejF,EAAOkF,IAAIC,SAASL,EAAQ,GAAGrE,IAAK,cAEzD,IAAI2E,EAAU,GACd,IACEA,EAAUC,OAAOC,WACTtF,EAAOC,UAAU8B,GAAGC,SAASiD,IACnCM,SAAS,OACb,CAAE,MAAO,CAEJH,EAAQjD,MAAM,SAASqD,SAASZ,UAC7B5E,EAAOC,UAAU8B,GAAG0C,UACxBQ,EACAI,OAAOC,KAAKF,EAAU,KAAOR,EAAW,KAAM,QAGpD,CAtFQc,CAAwBiI,EAChC,EArGA,kBAEA,YAEMA,EAAY,WAIlB,SAAS9L,IACP,MAAMiD,EAAU9E,EAAOC,UAAU8E,iBACjC,OAAKD,GAA8B,IAAnBA,EAAQV,OAIjBpE,EAAOkF,IAAIC,SAASL,EAAQ,GAAGrE,IAAKkN,IAHzC3N,EAAO4F,OAAOC,mBAAmB,uCAC1B,KAGX,CAEA,SAASiH,EAAcc,GACrB,OAAOA,EAAEC,QAAQ,MAAO,IAC1B,C,SCnBA1H,EAAOC,QAAUC,QAAQ,S,GCCrByH,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBlK,IAAjBmK,EACH,OAAOA,EAAa7H,QAGrB,IAAID,EAAS2H,EAAyBE,GAAY,CAGjD5H,QAAS,CAAC,GAOX,OAHA8H,EAAoBF,GAAUG,KAAKhI,EAAOC,QAASD,EAAQA,EAAOC,QAAS2H,GAGpE5H,EAAOC,OACf,C,wEClBA,oBAAyB6B,IAEvB,IAAAmG,cAAanG,IAEb,IAAAoG,mBAAkBpG,EAEpB,EAEA,wBAA8B,EAX9B,eACA,Q","sources":["webpack://to-do-changelog-manager/./src/todo/scanner.ts","webpack://to-do-changelog-manager/./src/changelog/persistence.ts","webpack://to-do-changelog-manager/external commonjs \"vscode\"","webpack://to-do-changelog-manager/./src/changelog/provider.ts","webpack://to-do-changelog-manager/./src/todo/index.ts","webpack://to-do-changelog-manager/./src/todo/provider.ts","webpack://to-do-changelog-manager/./src/changelog/index.ts","webpack://to-do-changelog-manager/external node-commonjs \"path\"","webpack://to-do-changelog-manager/./src/todo/persistence.ts","webpack://to-do-changelog-manager/external node-commonjs \"crypto\"","webpack://to-do-changelog-manager/webpack/bootstrap","webpack://to-do-changelog-manager/./src/extension.ts"],"sourcesContent":["import * as vscode from \"vscode\";\r\nimport * as path from \"path\";\r\nimport type { TodoItem } from \"./types\";\r\nimport { makeScannedTodo } from \"./persistence\";\r\n\r\nconst TODO_REGEX = /(\\/\\/\\s*TO-?DO)/i;\r\n\r\nexport async function scanTodosInWorkspace(): Promise<TodoItem[]> {\r\n  const todos: TodoItem[] = [];\r\n  const seen = new Set<string>();\r\n\r\n  const files = await vscode.workspace.findFiles(\r\n    \"**/*.{js,ts,jsx,tsx,py,java,go,cpp,c,h}\",\r\n    \"**/node_modules/**\"\r\n  );\r\n\r\n  for (const file of files) {\r\n    const doc = await vscode.workspace.openTextDocument(file);\r\n    const ws = vscode.workspace.getWorkspaceFolder(file);\r\n    const root = ws?.uri.fsPath;\r\n\r\n    for (let i = 0; i < doc.lineCount; i++) {\r\n      const text = doc.lineAt(i).text;\r\n      if (!TODO_REGEX.test(text)) continue;\r\n\r\n      const match = text.match(/(?:TODO:?|TO-DO:?)(.*)/i);\r\n      const raw = match ? match[1].trim() : \"\";\r\n\r\n      const rel = root ? path.relative(root, file.fsPath) : file.fsPath;\r\n\r\n      const todo = makeScannedTodo(raw, rel, i);\r\n\r\n      if (seen.has(todo.id)) continue;\r\n      seen.add(todo.id);\r\n\r\n      todos.push(todo);\r\n    }\r\n  }\r\n\r\n  return todos;\r\n}\r\n","import * as vscode from \"vscode\";\r\nimport type { ChangelogVersion, ChangelogEntry } from \"./types\";\r\n\r\nconst FILE_NAME = \"CHANGELOG.md\";\r\n\r\nconst SECTION_ORDER = [\r\n  \"Additions\",\r\n  \"Changes\",\r\n  \"Deprecations\",\r\n  \"Fixes\",\r\n  \"Removals\",\r\n  \"Security Changes\",\r\n] as const;\r\n\r\ntype SectionName = (typeof SECTION_ORDER)[number];\r\n\r\nfunction getFileUri(): vscode.Uri | null {\r\n  const folders = vscode.workspace.workspaceFolders;\r\n  if (!folders || folders.length === 0) {\r\n    vscode.window.showWarningMessage(\"Open a folder to use the changelog.\");\r\n    return null;\r\n  }\r\n  return vscode.Uri.joinPath(folders[0].uri, FILE_NAME);\r\n}\r\n\r\nconst decoder = new TextDecoder(\"utf-8\");\r\nconst encoder = new TextEncoder();\r\n\r\nexport async function readChangelog(): Promise<ChangelogVersion[]> {\r\n  const uri = getFileUri();\r\n  if (!uri) return [];\r\n\r\n  try {\r\n    const bytes = await vscode.workspace.fs.readFile(uri);\r\n    const md = decoder.decode(bytes);\r\n    return parseMd(md);\r\n  } catch {\r\n    // File missing or unreadable -> treat as empty changelog\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function writeChangelog(\r\n  versions: ChangelogVersion[]\r\n): Promise<void> {\r\n  const uri = getFileUri();\r\n  if (!uri) return;\r\n\r\n  const md = generateMd(versions);\r\n\r\n  // ‚ú® 1. Escribe el archivo\r\n  await vscode.workspace.fs.writeFile(uri, encoder.encode(md));\r\n\r\n  // ‚ú® 2. Asegura que el changelog est√© en .gitignore\r\n  const fileName = uri.path.split(\"/\").pop() ?? \"\";\r\n  await ensureGitignoreHasEntry(fileName);\r\n}\r\n\r\nasync function ensureGitignoreHasEntry(fileName: string) {\r\n  const folders = vscode.workspace.workspaceFolders;\r\n  if (!folders || folders.length === 0) {\r\n    return;\r\n  }\r\n\r\n  const rootUri = folders[0].uri;\r\n  const gitignoreUri = vscode.Uri.joinPath(rootUri, \".gitignore\");\r\n\r\n  let content = \"\";\r\n  try {\r\n    const bytes = await vscode.workspace.fs.readFile(gitignoreUri);\r\n    content = Buffer.from(bytes).toString(\"utf8\");\r\n  } catch {\r\n    // Si no existe .gitignore, content queda como \"\"\r\n  }\r\n\r\n  // Si ya est√°, salir\r\n  if (content.split(/\\r?\\n/).includes(fileName)) {\r\n    return;\r\n  }\r\n\r\n  // Agregar al final\r\n  const newContent =\r\n    content + (content.length > 0 ? \"\\n\" : \"\") + fileName + \"\\n\";\r\n  await vscode.workspace.fs.writeFile(\r\n    gitignoreUri,\r\n    Buffer.from(newContent, \"utf8\")\r\n  );\r\n}\r\n\r\n// ---- PARSE / GENERATE UTILS ---- //\r\n\r\nfunction emptySections(): Record<string, ChangelogEntry[]> {\r\n  const obj: Record<string, ChangelogEntry[]> = {};\r\n  for (const sn of SECTION_ORDER) obj[sn] = [];\r\n  return obj;\r\n}\r\n\r\nfunction normalizeSectionHeading(line: string): string | null {\r\n  // Expect: ### Additions\r\n  const m = line.match(/^###\\s+(.+)\\s*$/);\r\n  if (!m) return null;\r\n  return m[1].trim();\r\n}\r\n\r\nfunction parseVersionHeading(\r\n  line: string\r\n): { version: string; date: string } | null {\r\n  // Accept:\r\n  // ## 1.0.0 2026-01-09\r\n  // ## [1.0.0] 2026-01-09\r\n  // ## [1.0.0] - 2026-01-09\r\n  const m = line.match(\r\n    /^##\\s+(?:\\[(.+?)\\]|(\\S+))\\s*(?:-\\s*)?(\\d{4}-\\d{2}-\\d{2})\\s*$/\r\n  );\r\n  if (!m) return null;\r\n  const version = (m[1] ?? m[2])?.trim();\r\n  const date = m[3]?.trim();\r\n  if (!version || !date) return null;\r\n  return { version, date };\r\n}\r\n\r\nfunction parseEntry(line: string): string | null {\r\n  // Accept:\r\n  // - text\r\n  // - [2026-01-09 12:00] text  (we ignore date, keep text)\r\n  const m = line.match(/^- (?:\\[[^\\]]+\\]\\s*)?(.+)\\s*$/);\r\n  if (!m) return null;\r\n  return m[1].trim();\r\n}\r\n\r\nfunction parseMd(md: string): ChangelogVersion[] {\r\n  const lines = md.split(/\\r?\\n/);\r\n  const versions: ChangelogVersion[] = [];\r\n\r\n  let current: ChangelogVersion | null = null;\r\n  let section: string | null = null;\r\n\r\n  for (const rawLine of lines) {\r\n    const line = rawLine.trim();\r\n    if (!line) continue;\r\n\r\n    // Version line\r\n    const ver = parseVersionHeading(line);\r\n    if (ver) {\r\n      current = {\r\n        version: ver.version,\r\n        date: ver.date,\r\n        sections: emptySections(),\r\n      };\r\n      section = null;\r\n      versions.push(current);\r\n      continue;\r\n    }\r\n\r\n    if (!current) continue;\r\n\r\n    // Section heading\r\n    const secName = normalizeSectionHeading(line);\r\n    if (secName) {\r\n      // If it's a known section, use it; if unknown, create it dynamically\r\n      if (!current.sections[secName]) current.sections[secName] = [];\r\n      section = secName;\r\n      continue;\r\n    }\r\n\r\n    // Entry line\r\n    if (section && line.startsWith(\"- \")) {\r\n      const text = parseEntry(line);\r\n      if (!text) continue;\r\n\r\n      current.sections[section].push({ text });\r\n    }\r\n  }\r\n\r\n  return versions;\r\n}\r\n\r\nfunction generateMd(versions: ChangelogVersion[]): string {\r\n  const lines: string[] = [];\r\n\r\n  const sectionOrder = [\r\n    \"Additions\",\r\n    \"Changes\",\r\n    \"Deprecations\",\r\n    \"Fixes\",\r\n    \"Removals\",\r\n    \"Security Changes\",\r\n  ] as const;\r\n\r\n  const sorted = [...versions].sort((a, b) => {\r\n    const byDate = b.date.localeCompare(a.date); // YYYY-MM-DD\r\n    if (byDate !== 0) return byDate;\r\n\r\n    return String(b.version).localeCompare(String(a.version), undefined, {\r\n      numeric: true,\r\n    });\r\n  });\r\n\r\n  for (const v of sorted) {\r\n    const sectionsWithEntries = sectionOrder.filter(\r\n      (sec) => (v.sections?.[sec]?.length ?? 0) > 0\r\n    );\r\n\r\n    lines.push(`## ${v.version} ${v.date}`);\r\n\r\n    for (const secName of sectionsWithEntries) {\r\n      lines.push(\"\");\r\n      lines.push(`### ${secName}`);\r\n\r\n      const entries = v.sections[secName] as ChangelogEntry[];\r\n      for (const e of entries) {\r\n        lines.push(`- ${e.text}`);\r\n      }\r\n    }\r\n\r\n    lines.push(\"\");\r\n  }\r\n\r\n  return lines.join(\"\\n\");\r\n}\r\n","module.exports = require(\"vscode\");","import * as vscode from \"vscode\";\r\nimport type { ChangelogEntry, ChangelogVersion } from \"./types\";\r\nimport { readChangelog } from \"./persistence\";\r\n\r\ntype SectionKey =\r\n  | \"Additions\"\r\n  | \"Changes\"\r\n  | \"Deprecations\"\r\n  | \"Fixes\"\r\n  | \"Removals\"\r\n  | \"Security Changes\";\r\n\r\nconst sections: Array<{ key: SectionKey; label: string }> = [\r\n  { key: \"Additions\", label: \"üÜï Additions\" },\r\n  { key: \"Changes\", label: \"üîÉ Changes\" },\r\n  { key: \"Deprecations\", label: \"‚¨áÔ∏è Deprecations\" },\r\n  { key: \"Fixes\", label: \"üÜó Fixes\" },\r\n  { key: \"Removals\", label: \"üóëÔ∏è Removals\" },\r\n  { key: \"Security Changes\", label: \"üõ°Ô∏è Security Changes\" },\r\n];\r\n\r\ntype VersionNode = {\r\n  kind: \"version\";\r\n  version: string;\r\n  date: string;\r\n  sections: Record<string, ChangelogEntry[]>;\r\n};\r\n\r\ntype SectionNode = {\r\n  kind: \"section\";\r\n  key: SectionKey;      // <- key real\r\n  label: string;        // <- label bonito\r\n  count: number;\r\n  version: VersionNode;\r\n};\r\n\r\ntype EntryNode = {\r\n  kind: \"entry\";\r\n  text: string;\r\n  version: VersionNode;\r\n  section: SectionKey;\r\n};\r\n\r\ntype Node = VersionNode | SectionNode | EntryNode;\r\n\r\nexport class ChangelogProvider implements vscode.TreeDataProvider<Node> {\r\n  private _onDidChange = new vscode.EventEmitter<void>();\r\n  readonly onDidChangeTreeData = this._onDidChange.event;\r\n\r\n  private versions: VersionNode[] = [];\r\n\r\n  constructor() {\r\n    void this.load();\r\n  }\r\n\r\n  async load() {\r\n    const raw = await readChangelog();\r\n\r\n    this.versions = raw.map((v) => ({\r\n      kind: \"version\",\r\n      version: v.version,\r\n      date: v.date,\r\n      sections: v.sections,\r\n    }));\r\n\r\n    this._onDidChange.fire();\r\n  }\r\n\r\n  refresh() {\r\n    void this.load();\r\n  }\r\n\r\n  getTreeItem(element: Node): vscode.TreeItem {\r\n    if (element.kind === \"version\") {\r\n      const label = `${element.version}   ${element.date}`;\r\n      const ti = new vscode.TreeItem(label, vscode.TreeItemCollapsibleState.Collapsed);\r\n      ti.contextValue = \"changelogVersion\";\r\n      return ti;\r\n    }\r\n\r\n    if (element.kind === \"section\") {\r\n      const ti = new vscode.TreeItem(\r\n        `${element.label} (${element.count})`,\r\n        vscode.TreeItemCollapsibleState.Collapsed\r\n      );\r\n      ti.contextValue = \"changelogSection\";\r\n      return ti;\r\n    }\r\n\r\n    // entry\r\n    const ti = new vscode.TreeItem(`üî∏ ${element.text}`, vscode.TreeItemCollapsibleState.None);\r\n    ti.contextValue = \"changelogEntry\";\r\n    return ti;\r\n  }\r\n\r\n  getChildren(element?: Node): Thenable<Node[]> {\r\n    if (!element) {\r\n      return Promise.resolve(\r\n        [...this.versions].sort((a, b) => b.date.localeCompare(a.date))\r\n      );\r\n    }\r\n\r\n    if (element.kind === \"version\") {\r\n      return Promise.resolve(\r\n        sections.map(({ key, label }) => {\r\n          const count = element.sections[key]?.length ?? 0;\r\n\r\n          const node: SectionNode = {\r\n            kind: \"section\",\r\n            key,\r\n            label,\r\n            count,\r\n            version: element,\r\n          };\r\n\r\n          return node;\r\n        })\r\n      );\r\n    }\r\n\r\n    // Section -> entries\r\n    if (element.kind === \"section\") {\r\n      const ver = element.version;\r\n      const list = ver.sections[element.key] ?? [];\r\n\r\n      return Promise.resolve(\r\n        list.map((e) => ({\r\n          kind: \"entry\",\r\n          text: e.text,\r\n          version: ver,\r\n          section: element.key,\r\n        }))\r\n      );\r\n    }\r\n\r\n    return Promise.resolve([]);\r\n  }\r\n}\r\n","import * as vscode from \"vscode\";\r\n\r\nimport type { TodoItem as TodoType } from \"./types\";\r\nimport { TodoProvider } from \"./provider\";\r\n\r\n// Funciones de persistencia\r\nimport { readTodos, writeTodos } from \"./persistence\";\r\n\r\n// Esc√°ner de TODOs en archivos\r\nimport { scanTodosInWorkspace } from \"./scanner\";\r\n\r\nexport function registerTodo(context: vscode.ExtensionContext) {\r\n  const provider = new TodoProvider();\r\n  vscode.window.registerTreeDataProvider(\"todoView\", provider);\r\n\r\n  context.subscriptions.push(\r\n    // Agregar tarea manual\r\n    vscode.commands.registerCommand(\"todo.add\", async () => {\r\n      const text = await vscode.window.showInputBox({\r\n        prompt: \"Add a new task\",\r\n      });\r\n      if (text) {\r\n        await provider.add(text.trim());\r\n      }\r\n    }),\r\n\r\n    // Marcar como completada\r\n    vscode.commands.registerCommand(\r\n      \"todo.complete\",\r\n      (item?: TodoType) => item && provider.complete(item)\r\n    ),\r\n\r\n    // Marcar como incompleta\r\n    vscode.commands.registerCommand(\r\n      \"todo.uncomplete\",\r\n      (item?: TodoType) => item && provider.uncomplete(item)\r\n    ),\r\n\r\n    // Refrescar lista\r\n    vscode.commands.registerCommand(\"todo.refresh\", () => {\r\n      provider.refresh();\r\n    }),\r\n\r\n    // Editar texto de tarea\r\n    vscode.commands.registerCommand(\r\n      \"todo.edit\",\r\n      async (item?: TodoType) => {\r\n        if (!item) return;\r\n\r\n        const text = await vscode.window.showInputBox({\r\n          prompt: \"Edit task\",\r\n          value: item.text,\r\n        });\r\n\r\n        if (text) {\r\n          await provider.edit(item, text.trim());\r\n        }\r\n      }\r\n    ),\r\n\r\n    // Eliminar tarea\r\n    vscode.commands.registerCommand(\r\n      \"todo.remove\",\r\n      async (item?: TodoType) => {\r\n        if (!item) return;\r\n        await provider.remove(item);\r\n      }\r\n    ),\r\n\r\n    // ‚ú® Nuevo: Escanear TODOs dentro de archivos del proyecto\r\n    vscode.commands.registerCommand(\"todo.scanFiles\", async () => {\r\n      try {\r\n        // Busca TODOs en todos los archivos\r\n        const found = await scanTodosInWorkspace();\r\n\r\n        if (found.length === 0) {\r\n          vscode.window.showInformationMessage(\r\n            \"No TODOs found in project files.\"\r\n          );\r\n          return;\r\n        }\r\n\r\n        // Leer tareas existentes\r\n        const existing = await readTodos();\r\n\r\n        // Concatenar (puedes luego hacer deduplicaci√≥n si quieres)\r\n        const combined = [...existing, ...found];\r\n\r\n        // Guardar todo en persistencia\r\n        await writeTodos(combined);\r\n\r\n        // Refrescar lista\r\n        provider.refresh();\r\n\r\n        vscode.window.showInformationMessage(\r\n          `Added ${found.length} TODOs found in project files.`\r\n        );\r\n      } catch (err) {\r\n        console.error(\"Error scanning TODOs:\", err);\r\n        vscode.window.showErrorMessage(\r\n          \"Failed to scan TODOs in project files.\"\r\n        );\r\n      }\r\n    })\r\n  );\r\n}\r\n","import * as vscode from \"vscode\";\r\nimport type { TodoItem } from \"./types\";\r\nimport { readTodos, writeTodos, makeTodo } from \"./persistence\";\r\n\r\nexport class TodoProvider implements vscode.TreeDataProvider<TodoItem> {\r\n  private _onDidChange = new vscode.EventEmitter<void>();\r\n  readonly onDidChangeTreeData = this._onDidChange.event;\r\n\r\n  private items: TodoItem[] = [];\r\n\r\n  constructor() {\r\n    void this.load();\r\n  }\r\n\r\n  async load() {\r\n    const all = await readTodos();\r\n\r\n    this.items = [\r\n      ...all.filter((t) => !t.completed),\r\n      ...all.filter((t) => t.completed),\r\n    ];\r\n\r\n    this._onDidChange.fire();\r\n  }\r\n\r\n  refresh() {\r\n    void this.load();\r\n  }\r\n\r\n  getTreeItem(item: TodoItem): vscode.TreeItem {\r\n    const label = `${item.text}`;\r\n    const treeItem = new vscode.TreeItem(label);\r\n\r\n    if (item.relativePath && typeof item.line === \"number\") {\r\n      const root = vscode.workspace.workspaceFolders?.[0];\r\n      if (root) {\r\n        const uri = vscode.Uri.joinPath(root.uri, item.relativePath);\r\n        treeItem.command = {\r\n          command: \"vscode.open\",\r\n          title: \"Open\",\r\n          arguments: [\r\n            uri,\r\n            { selection: new vscode.Range(item.line, 0, item.line, 0) },\r\n          ],\r\n        };\r\n        treeItem.description = `${item.relativePath}:${item.line + 1}`;\r\n      }\r\n    }\r\n\r\n    treeItem.contextValue = item.completed ? \"done\" : \"pending\";\r\n    return treeItem;\r\n  }\r\n\r\n  getChildren(): Thenable<TodoItem[]> {\r\n    return Promise.resolve(this.items);\r\n  }\r\n\r\n  async add(text: string) {\r\n    const todos = await readTodos();\r\n    todos.push(makeTodo(text));\r\n    await writeTodos(todos);\r\n    this.refresh();\r\n  }\r\n\r\n  async addScanned(found: TodoItem[]) {\r\n    if (found.length === 0) return;\r\n\r\n    const existing = await readTodos();\r\n    const map = new Map<string, TodoItem>();\r\n\r\n    for (const t of existing) map.set(t.id, t);\r\n    for (const t of found) if (!map.has(t.id)) map.set(t.id, t);\r\n\r\n    await writeTodos([...map.values()]);\r\n    this.refresh();\r\n  }\r\n\r\n  async edit(item: TodoItem, newText: string): Promise<void> {\r\n    const todos = await readTodos();\r\n    const todo = todos.find((t) => t.id === item.id);\r\n    if (!todo) return;\r\n\r\n    todo.text = newText;\r\n    await writeTodos(todos);\r\n    this.refresh();\r\n  }\r\n\r\n  // Marcar como incompleta\r\n  async uncomplete(item?: TodoItem): Promise<void> {\r\n    if (!item) return;\r\n\r\n    const todos = await readTodos();\r\n    const todo = todos.find((t) => t.id === item.id);\r\n    if (!todo) return;\r\n\r\n    todo.completed = false;\r\n    todo.date_finished = null;\r\n\r\n    await writeTodos(todos);\r\n    this.refresh();\r\n  }\r\n\r\n  async complete(item: TodoItem) {\r\n    const todos = await readTodos();\r\n    const t = todos.find((x) => x.id === item.id);\r\n    if (!t) return;\r\n\r\n    t.completed = true;\r\n    t.date_finished = new Date().toISOString();\r\n    await writeTodos(todos);\r\n    this.refresh();\r\n  }\r\n\r\n  async remove(item: TodoItem) {\r\n    await writeTodos((await readTodos()).filter((t) => t.id !== item.id));\r\n    this.refresh();\r\n  }\r\n}\r\n","import * as vscode from \"vscode\";\r\nimport { ChangelogProvider } from \"./provider\";\r\nimport { readChangelog, writeChangelog } from \"./persistence\";\r\n\r\nexport function registerChangelog(context: vscode.ExtensionContext) {\r\n  const provider = new ChangelogProvider();\r\n\r\n  const treeReg = vscode.window.registerTreeDataProvider(\"changelogView\", provider);\r\n  context.subscriptions.push(treeReg);\r\n\r\n  context.subscriptions.push(\r\n    vscode.commands.registerCommand(\"changelog.refresh\", () => {\r\n      provider.refresh();\r\n    })\r\n  );\r\n\r\n  context.subscriptions.push(\r\n    vscode.commands.registerCommand(\"changelog.addVersion\", async () => {\r\n      const version = await vscode.window.showInputBox({\r\n        prompt: \"New version (e.g., 1.0.0)\",\r\n      });\r\n      if (!version) return;\r\n\r\n      const date = new Date().toISOString().split(\"T\")[0];\r\n      const all = await readChangelog();\r\n\r\n      const exists = all.some((v) => v.version === version);\r\n      if (exists) {\r\n        vscode.window.showWarningMessage(`Version \"${version}\" already exists!`);\r\n        return;\r\n      }\r\n\r\n      all.unshift({\r\n        version,\r\n        date,\r\n        sections: {\r\n          Additions: [],\r\n          Changes: [],\r\n          Deprecations: [],\r\n          Fixes: [],\r\n          Removals: [],\r\n          \"Security Changes\": [],\r\n        },\r\n      });\r\n\r\n      await writeChangelog(all);\r\n      provider.refresh();\r\n    })\r\n  );\r\n\r\n  context.subscriptions.push(\r\n    vscode.commands.registerCommand(\"changelog.addEntry\", async (node: any) => {\r\n      const versionObj = node.version; \r\n\r\n      const sectionKey: string = node.key ?? node.name;\r\n      const sectionLabel: string = node.label ?? node.name ?? sectionKey;\r\n\r\n      const text = await vscode.window.showInputBox({\r\n        prompt: `Add entry to ${sectionLabel}`,\r\n        placeHolder: \"Describe the change...\",\r\n      });\r\n      if (!text) return;\r\n\r\n      const all = await readChangelog();\r\n      const versionIdx = all.findIndex((v) => v.version === versionObj.version);\r\n      if (versionIdx === -1) return;\r\n\r\n      if (!all[versionIdx].sections[sectionKey]) {\r\n        all[versionIdx].sections[sectionKey] = [];\r\n      }\r\n\r\n      all[versionIdx].sections[sectionKey].push({ text });\r\n\r\n      await writeChangelog(all);\r\n      provider.refresh();\r\n    })\r\n  );\r\n\r\n  context.subscriptions.push(\r\n    vscode.commands.registerCommand(\"changelog.editEntry\", async (node: any) => {\r\n      const newText = await vscode.window.showInputBox({\r\n        prompt: \"Edit entry text\",\r\n        value: node.text,\r\n      });\r\n      if (!newText) return;\r\n\r\n      const all = await readChangelog();\r\n      const versionIdx = all.findIndex((v) => v.version === node.version.version);\r\n      if (versionIdx === -1) return;\r\n\r\n      const secArr = all[versionIdx].sections[node.section] ?? [];\r\n      all[versionIdx].sections[node.section] = secArr;\r\n\r\n      const entryIdx = secArr.findIndex((e: any) => e.text === node.text);\r\n      if (entryIdx === -1) return;\r\n\r\n      secArr[entryIdx].text = newText;\r\n\r\n      await writeChangelog(all);\r\n      provider.refresh();\r\n    })\r\n  );\r\n\r\n  context.subscriptions.push(\r\n    vscode.commands.registerCommand(\"changelog.removeEntry\", async (node: any) => {\r\n      const confirm = await vscode.window.showWarningMessage(\r\n        `Remove this entry?\\n\"${node.text}\"`,\r\n        { modal: true },\r\n        \"Yes\"\r\n      );\r\n      if (confirm !== \"Yes\") return;\r\n\r\n      const all = await readChangelog();\r\n      const versionIdx = all.findIndex((v) => v.version === node.version.version);\r\n      if (versionIdx === -1) return;\r\n\r\n      const secArr = all[versionIdx].sections[node.section] ?? [];\r\n      all[versionIdx].sections[node.section] = secArr.filter((e: any) => e.text !== node.text);\r\n\r\n      await writeChangelog(all);\r\n      provider.refresh();\r\n    })\r\n  );\r\n\r\n  context.subscriptions.push(\r\n    vscode.commands.registerCommand(\"changelog.removeVersion\", async (node: any) => {\r\n      const confirm = await vscode.window.showWarningMessage(\r\n        `Remove version \"${node.version}\" and all its entries?`,\r\n        { modal: true },\r\n        \"Yes\"\r\n      );\r\n      if (confirm !== \"Yes\") return;\r\n\r\n      const all = await readChangelog();\r\n      const filtered = all.filter((v) => v.version !== node.version);\r\n\r\n      await writeChangelog(filtered);\r\n      provider.refresh();\r\n    })\r\n  );\r\n}\r\n","module.exports = require(\"path\");","import * as vscode from \"vscode\";\r\nimport type { TodoItem } from \"./types\";\r\nimport * as crypto from \"crypto\";\r\n\r\nconst FILE_NAME = \"TO-DO.md\";\r\n\r\n/* ---------------- PATH ---------------- */\r\n\r\nfunction getFileUri(): vscode.Uri | null {\r\n  const folders = vscode.workspace.workspaceFolders;\r\n  if (!folders || folders.length === 0) {\r\n    vscode.window.showWarningMessage(\"Open a folder first to save TO-DOs.\");\r\n    return null;\r\n  }\r\n  return vscode.Uri.joinPath(folders[0].uri, FILE_NAME);\r\n}\r\n\r\nfunction normalizePath(p: string): string {\r\n  return p.replace(/\\\\/g, \"/\");\r\n}\r\n\r\n/* ---------------- ID (SCAN) ---------------- */\r\n\r\nfunction makeSourceKey(\r\n  relativePath: string,\r\n  line: number,\r\n  text: string\r\n): string {\r\n  const t = text.trim().slice(0, 32);\r\n  return `${normalizePath(relativePath)}:${line}:${t}`;\r\n}\r\n\r\nfunction hashId(input: string): string {\r\n  return crypto.createHash(\"sha256\").update(input).digest(\"hex\").slice(0, 16);\r\n}\r\n\r\n/* ---------------- FACTORIES ---------------- */\r\n\r\n// üî¥ SOLO para TODOs manuales\r\nexport function makeTodo(text: string): TodoItem {\r\n  return {\r\n    id: crypto.randomUUID(),\r\n    text,\r\n    completed: false,\r\n    date_added: new Date().toISOString(),\r\n    date_finished: null,\r\n  };\r\n}\r\n\r\n// üü¢ SOLO para TODOs escaneados\r\nexport function makeScannedTodo(\r\n  text: string,\r\n  relativePath: string,\r\n  line: number\r\n): TodoItem {\r\n  const cleanText = text.trim() || \"TODO\";\r\n  const sourceKey = makeSourceKey(relativePath, line, cleanText);\r\n  const id = hashId(sourceKey);\r\n\r\n  return {\r\n    id,\r\n    text: cleanText,\r\n    completed: false,\r\n    date_added: new Date().toISOString(),\r\n    date_finished: null,\r\n    relativePath: normalizePath(relativePath),\r\n    line,\r\n    sourceKey,\r\n  };\r\n}\r\n\r\n/* ---------------- READ ---------------- */\r\n\r\nexport async function readTodos(): Promise<TodoItem[]> {\r\n  const uri = getFileUri();\r\n  if (!uri) return [];\r\n\r\n  try {\r\n    const bytes = await vscode.workspace.fs.readFile(uri);\r\n    return parseMarkdown(Buffer.from(bytes).toString(\"utf8\"));\r\n  } catch {\r\n    return [];\r\n  }\r\n}\r\n\r\n/* ---------------- WRITE ---------------- */\r\n\r\nexport async function writeTodos(items: TodoItem[]): Promise<void> {\r\n  const uri = getFileUri();\r\n  if (!uri) return;\r\n\r\n  // üî• blindaje final\r\n  const map = new Map<string, TodoItem>();\r\n  for (const t of items) {\r\n    if (!map.has(t.id)) map.set(t.id, t);\r\n  }\r\n\r\n  const md = generateMarkdown([...map.values()]);\r\n  await vscode.workspace.fs.writeFile(uri, Buffer.from(md, \"utf8\"));\r\n\r\n  await ensureGitignoreHasEntry(FILE_NAME);\r\n}\r\n\r\n/* ---------------- PARSE ---------------- */\r\n\r\nfunction parseMarkdown(md: string): TodoItem[] {\r\n  const todos: TodoItem[] = [];\r\n\r\n  for (const line of md.split(/\\r?\\n/)) {\r\n    const m = line.match(/^- \\[( |x)\\] (.+?)(?: <!-- (.+) -->)?$/);\r\n    if (!m) continue;\r\n\r\n    const completed = m[1] === \"x\";\r\n    const text = m[2];\r\n    const metaRaw = m[3];\r\n\r\n    if (!metaRaw) continue;\r\n\r\n    try {\r\n      const meta = JSON.parse(metaRaw);\r\n\r\n      todos.push({\r\n        id: meta.id,\r\n        text,\r\n        completed,\r\n        date_added: meta.date_added,\r\n        date_finished: meta.date_finished ?? null,\r\n        relativePath: meta.relativePath,\r\n        line: meta.line,\r\n        sourceKey: meta.sourceKey,\r\n      });\r\n    } catch {\r\n      // ignore\r\n    }\r\n  }\r\n\r\n  return todos;\r\n}\r\n\r\n/* ---------------- GENERATE ---------------- */\r\n\r\nfunction generateMarkdown(items: TodoItem[]): string {\r\n  const lines: string[] = [\"# TO-DO\", \"\"];\r\n\r\n  for (const item of items) {\r\n    const meta = {\r\n      id: item.id,\r\n      date_added: item.date_added,\r\n      date_finished: item.date_finished ?? null,\r\n      relativePath: item.relativePath,\r\n      line: item.line,\r\n      sourceKey: item.sourceKey,\r\n    };\r\n\r\n    lines.push(\r\n      `- [${item.completed ? \"x\" : \" \"}] ${item.text} <!-- ${JSON.stringify(\r\n        meta\r\n      )} -->`\r\n    );\r\n  }\r\n\r\n  lines.push(\"\");\r\n  return lines.join(\"\\n\");\r\n}\r\n\r\n/* ---------------- GITIGNORE ---------------- */\r\n\r\nasync function ensureGitignoreHasEntry(fileName: string) {\r\n  const folders = vscode.workspace.workspaceFolders;\r\n  if (!folders || folders.length === 0) return;\r\n\r\n  const gitignoreUri = vscode.Uri.joinPath(folders[0].uri, \".gitignore\");\r\n\r\n  let content = \"\";\r\n  try {\r\n    content = Buffer.from(\r\n      await vscode.workspace.fs.readFile(gitignoreUri)\r\n    ).toString(\"utf8\");\r\n  } catch {}\r\n\r\n  if (!content.split(/\\r?\\n/).includes(fileName)) {\r\n    await vscode.workspace.fs.writeFile(\r\n      gitignoreUri,\r\n      Buffer.from(content + \"\\n\" + fileName + \"\\n\", \"utf8\")\r\n    );\r\n  }\r\n}\r\n","module.exports = require(\"crypto\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import * as vscode from \"vscode\";\r\nimport { registerTodo } from \"./todo/index\";\r\nimport { registerChangelog } from \"./changelog/index\";\r\n\r\nexport function activate(context: vscode.ExtensionContext) {\r\n\r\n  registerTodo(context);\r\n\r\n  registerChangelog(context);\r\n\r\n}\r\n\r\nexport function deactivate() {}\r\n"],"names":["async","todos","seen","Set","files","vscode","workspace","findFiles","file","doc","openTextDocument","ws","getWorkspaceFolder","root","uri","fsPath","i","lineCount","text","lineAt","TODO_REGEX","test","match","raw","trim","rel","path","relative","todo","makeScannedTodo","has","id","add","push","getFileUri","bytes","fs","readFile","md","lines","split","versions","current","section","rawLine","line","ver","parseVersionHeading","version","date","sections","emptySections","secName","normalizeSectionHeading","startsWith","parseEntry","parseMd","decoder","decode","sectionOrder","sorted","sort","a","b","byDate","localeCompare","String","undefined","numeric","v","sectionsWithEntries","filter","sec","length","entries","e","join","generateMd","writeFile","encoder","encode","fileName","pop","folders","workspaceFolders","rootUri","gitignoreUri","Uri","joinPath","content","Buffer","from","toString","includes","newContent","ensureGitignoreHasEntry","SECTION_ORDER","window","showWarningMessage","TextDecoder","TextEncoder","obj","sn","m","module","exports","require","key","label","_onDidChange","EventEmitter","onDidChangeTreeData","this","event","constructor","load","readChangelog","map","kind","fire","refresh","getTreeItem","element","ti","TreeItem","TreeItemCollapsibleState","Collapsed","contextValue","count","None","getChildren","Promise","resolve","list","context","provider","TodoProvider","registerTreeDataProvider","subscriptions","commands","registerCommand","showInputBox","prompt","item","complete","uncomplete","value","edit","remove","found","scanTodosInWorkspace","showInformationMessage","combined","readTodos","writeTodos","err","console","error","showErrorMessage","items","all","t","completed","treeItem","relativePath","command","title","arguments","selection","Range","description","makeTodo","addScanned","existing","Map","set","values","newText","find","date_finished","x","Date","toISOString","ChangelogProvider","treeReg","some","unshift","Additions","Changes","Deprecations","Fixes","Removals","writeChangelog","node","versionObj","sectionKey","name","sectionLabel","placeHolder","versionIdx","findIndex","secArr","entryIdx","modal","filtered","crypto","randomUUID","date_added","cleanText","sourceKey","slice","normalizePath","makeSourceKey","input","createHash","update","digest","metaRaw","meta","JSON","parse","parseMarkdown","stringify","generateMarkdown","FILE_NAME","p","replace","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call","registerTodo","registerChangelog"],"ignoreList":[],"sourceRoot":""}