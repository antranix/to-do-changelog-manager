{"version":3,"file":"extension.js","mappings":"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","sources":["webpack://to-do-changelog-manager/./src/todo/scanner.ts","webpack://to-do-changelog-manager/./src/changelog/persistence.ts","webpack://to-do-changelog-manager/external commonjs \"vscode\"","webpack://to-do-changelog-manager/./src/todo/fileSync.ts","webpack://to-do-changelog-manager/./src/changelog/provider.ts","webpack://to-do-changelog-manager/./src/todo/index.ts","webpack://to-do-changelog-manager/./src/todo/provider.ts","webpack://to-do-changelog-manager/./src/changelog/index.ts","webpack://to-do-changelog-manager/external node-commonjs \"path\"","webpack://to-do-changelog-manager/./src/todo/persistence.ts","webpack://to-do-changelog-manager/external node-commonjs \"fs/promises\"","webpack://to-do-changelog-manager/external node-commonjs \"crypto\"","webpack://to-do-changelog-manager/webpack/bootstrap","webpack://to-do-changelog-manager/./src/extension.ts"],"sourcesContent":["import * as vscode from \"vscode\";\r\nimport * as path from \"path\";\r\nimport type { TodoItem } from \"./types\";\r\nimport { makeScannedTodo } from \"./persistence\";\r\n\r\nconst TODO_REGEX = /(\\/\\/\\s*TO-?DO)/i;\r\n\r\nexport async function scanTodosInWorkspace(): Promise<TodoItem[]> {\r\n  const todos: TodoItem[] = [];\r\n  const seen = new Set<string>();\r\n\r\n  const files = await vscode.workspace.findFiles(\r\n    \"**/*.{js,ts,jsx,tsx,py,java,go,cpp,c,h}\",\r\n    \"**/node_modules/**\"\r\n  );\r\n\r\n  for (const file of files) {\r\n    const doc = await vscode.workspace.openTextDocument(file);\r\n    const ws = vscode.workspace.getWorkspaceFolder(file);\r\n    const root = ws?.uri.fsPath;\r\n\r\n    for (let i = 0; i < doc.lineCount; i++) {\r\n      const text = doc.lineAt(i).text;\r\n      if (!TODO_REGEX.test(text)) continue;\r\n\r\n      const match = text.match(/(?:TODO:?|TO-DO:?)(.*)/i);\r\n      const raw = match ? match[1].trim() : \"\";\r\n\r\n      const rel = root ? path.relative(root, file.fsPath) : file.fsPath;\r\n\r\n      const todo = makeScannedTodo(raw, rel, i);\r\n\r\n      if (seen.has(todo.id)) continue;\r\n      seen.add(todo.id);\r\n\r\n      todos.push(todo);\r\n    }\r\n  }\r\n\r\n  return todos;\r\n}\r\n","import * as vscode from \"vscode\";\r\nimport type { ChangelogVersion, ChangelogEntry } from \"./types\";\r\n\r\nconst FILE_NAME = \"CHANGELOG.md\";\r\n\r\nconst SECTION_ORDER = [\r\n  \"Additions\",\r\n  \"Changes\",\r\n  \"Deprecations\",\r\n  \"Fixes\",\r\n  \"Removals\",\r\n  \"Security Changes\",\r\n] as const;\r\n\r\ntype SectionName = (typeof SECTION_ORDER)[number];\r\n\r\nfunction getFileUri(): vscode.Uri | null {\r\n  const folders = vscode.workspace.workspaceFolders;\r\n  if (!folders || folders.length === 0) {\r\n    vscode.window.showWarningMessage(\"Open a folder to use the changelog.\");\r\n    return null;\r\n  }\r\n  return vscode.Uri.joinPath(folders[0].uri, FILE_NAME);\r\n}\r\n\r\nconst decoder = new TextDecoder(\"utf-8\");\r\nconst encoder = new TextEncoder();\r\n\r\nexport async function readChangelog(): Promise<ChangelogVersion[]> {\r\n  const uri = getFileUri();\r\n  if (!uri) return [];\r\n\r\n  try {\r\n    const bytes = await vscode.workspace.fs.readFile(uri);\r\n    const md = decoder.decode(bytes);\r\n    return parseMd(md);\r\n  } catch {\r\n    // File missing or unreadable -> treat as empty changelog\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function writeChangelog(\r\n  versions: ChangelogVersion[]\r\n): Promise<void> {\r\n  const uri = getFileUri();\r\n  if (!uri) return;\r\n\r\n  const md = generateMd(versions);\r\n\r\n  // ‚ú® 1. Escribe el archivo\r\n  await vscode.workspace.fs.writeFile(uri, encoder.encode(md));\r\n\r\n  // ‚ú® 2. Asegura que el changelog est√© en .gitignore\r\n  const fileName = uri.path.split(\"/\").pop() ?? \"\";\r\n  await ensureGitignoreHasEntry(fileName);\r\n}\r\n\r\nasync function ensureGitignoreHasEntry(fileName: string) {\r\n  const folders = vscode.workspace.workspaceFolders;\r\n  if (!folders || folders.length === 0) {\r\n    return;\r\n  }\r\n\r\n  const rootUri = folders[0].uri;\r\n  const gitignoreUri = vscode.Uri.joinPath(rootUri, \".gitignore\");\r\n\r\n  let content = \"\";\r\n  try {\r\n    const bytes = await vscode.workspace.fs.readFile(gitignoreUri);\r\n    content = Buffer.from(bytes).toString(\"utf8\");\r\n  } catch {\r\n    // Si no existe .gitignore, content queda como \"\"\r\n  }\r\n\r\n  // Si ya est√°, salir\r\n  if (content.split(/\\r?\\n/).includes(fileName)) {\r\n    return;\r\n  }\r\n\r\n  // Agregar al final\r\n  const newContent =\r\n    content + (content.length > 0 ? \"\\n\" : \"\") + fileName + \"\\n\";\r\n  await vscode.workspace.fs.writeFile(\r\n    gitignoreUri,\r\n    Buffer.from(newContent, \"utf8\")\r\n  );\r\n}\r\n\r\n// ---- PARSE / GENERATE UTILS ---- //\r\n\r\nfunction emptySections(): Record<string, ChangelogEntry[]> {\r\n  const obj: Record<string, ChangelogEntry[]> = {};\r\n  for (const sn of SECTION_ORDER) obj[sn] = [];\r\n  return obj;\r\n}\r\n\r\nfunction normalizeSectionHeading(line: string): string | null {\r\n  // Expect: ### Additions\r\n  const m = line.match(/^###\\s+(.+)\\s*$/);\r\n  if (!m) return null;\r\n  return m[1].trim();\r\n}\r\n\r\nfunction parseVersionHeading(\r\n  line: string\r\n): { version: string; date: string } | null {\r\n  // Accept:\r\n  // ## 1.0.0 2026-01-09\r\n  // ## [1.0.0] 2026-01-09\r\n  // ## [1.0.0] - 2026-01-09\r\n  const m = line.match(\r\n    /^##\\s+(?:\\[(.+?)\\]|(\\S+))\\s*(?:-\\s*)?(\\d{4}-\\d{2}-\\d{2})\\s*$/\r\n  );\r\n  if (!m) return null;\r\n  const version = (m[1] ?? m[2])?.trim();\r\n  const date = m[3]?.trim();\r\n  if (!version || !date) return null;\r\n  return { version, date };\r\n}\r\n\r\nfunction parseEntry(line: string): string | null {\r\n  // Accept:\r\n  // - text\r\n  // - [2026-01-09 12:00] text  (we ignore date, keep text)\r\n  const m = line.match(/^- (?:\\[[^\\]]+\\]\\s*)?(.+)\\s*$/);\r\n  if (!m) return null;\r\n  return m[1].trim();\r\n}\r\n\r\nfunction parseMd(md: string): ChangelogVersion[] {\r\n  const lines = md.split(/\\r?\\n/);\r\n  const versions: ChangelogVersion[] = [];\r\n\r\n  let current: ChangelogVersion | null = null;\r\n  let section: string | null = null;\r\n\r\n  for (const rawLine of lines) {\r\n    const line = rawLine.trim();\r\n    if (!line) continue;\r\n\r\n    // Version line\r\n    const ver = parseVersionHeading(line);\r\n    if (ver) {\r\n      current = {\r\n        version: ver.version,\r\n        date: ver.date,\r\n        sections: emptySections(),\r\n      };\r\n      section = null;\r\n      versions.push(current);\r\n      continue;\r\n    }\r\n\r\n    if (!current) continue;\r\n\r\n    // Section heading\r\n    const secName = normalizeSectionHeading(line);\r\n    if (secName) {\r\n      // If it's a known section, use it; if unknown, create it dynamically\r\n      if (!current.sections[secName]) current.sections[secName] = [];\r\n      section = secName;\r\n      continue;\r\n    }\r\n\r\n    // Entry line\r\n    if (section && line.startsWith(\"- \")) {\r\n      const text = parseEntry(line);\r\n      if (!text) continue;\r\n\r\n      current.sections[section].push({ text });\r\n    }\r\n  }\r\n\r\n  return versions;\r\n}\r\n\r\nfunction generateMd(versions: ChangelogVersion[]): string {\r\n  const lines: string[] = [];\r\n\r\n  const sectionOrder = [\r\n    \"Additions\",\r\n    \"Changes\",\r\n    \"Deprecations\",\r\n    \"Fixes\",\r\n    \"Removals\",\r\n    \"Security Changes\",\r\n  ] as const;\r\n\r\n  const sorted = [...versions].sort((a, b) => {\r\n    const byDate = b.date.localeCompare(a.date); // YYYY-MM-DD\r\n    if (byDate !== 0) return byDate;\r\n\r\n    return String(b.version).localeCompare(String(a.version), undefined, {\r\n      numeric: true,\r\n    });\r\n  });\r\n\r\n  for (const v of sorted) {\r\n    const sectionsWithEntries = sectionOrder.filter(\r\n      (sec) => (v.sections?.[sec]?.length ?? 0) > 0\r\n    );\r\n\r\n    lines.push(`## ${v.version} ${v.date}`);\r\n\r\n    for (const secName of sectionsWithEntries) {\r\n      lines.push(\"\");\r\n      lines.push(`### ${secName}`);\r\n\r\n      const entries = v.sections[secName] as ChangelogEntry[];\r\n      for (const e of entries) {\r\n        lines.push(`- ${e.text}`);\r\n      }\r\n    }\r\n\r\n    lines.push(\"\");\r\n  }\r\n\r\n  return lines.join(\"\\n\");\r\n}\r\n","module.exports = require(\"vscode\");","import * as vscode from \"vscode\";\r\nimport * as fs from \"fs/promises\";\r\nimport * as path from \"path\";\r\nimport type { TodoItem } from \"./types\";\r\nimport { readTodos, writeTodos } from \"./persistence\";\r\n\r\n/**\r\n * Al refrescar: si la l√≠nea ya no existe en el archivo vinculado,\r\n * marcar la tarea como completada.\r\n */\r\nexport async function syncOnRefresh() {\r\n  const todos = await readTodos();\r\n  let updated = false;\r\n\r\n  for (const t of todos) {\r\n    if (!t.relativePath || t.completed) continue;\r\n\r\n    try {\r\n      const root = vscode.workspace.workspaceFolders?.[0];\r\n      if (!root) continue;\r\n\r\n      const filePath = path.join(root.uri.fsPath, t.relativePath);\r\n      const content = await fs.readFile(filePath, \"utf-8\");\r\n\r\n      // Si la l√≠nea ya no est√° en el archivo\r\n      if (!content.includes(t.text)) {\r\n        t.completed = true;\r\n        t.date_finished = new Date().toISOString();\r\n        updated = true;\r\n      }\r\n    } catch (e) {\r\n      console.error(\"Error leyendo archivo para sincronizaci√≥n:\", e);\r\n    }\r\n  }\r\n\r\n  if (updated) await writeTodos(todos);\r\n}\r\n\r\n/**\r\n * Elimina la l√≠nea del archivo vinculado cuando la tarea se completa.\r\n */\r\nexport async function removeFromLinkedFile(item: TodoItem) {\r\n  if (!item.relativePath) return;\r\n\r\n  const root = vscode.workspace.workspaceFolders?.[0];\r\n  if (!root) return;\r\n\r\n  try {\r\n    const filePath = path.join(root.uri.fsPath, item.relativePath);\r\n    const content = await fs.readFile(filePath, \"utf-8\");\r\n    const lines = content.split(/\\r?\\n/);\r\n\r\n    const newContent = lines\r\n      .filter((line) => !line.includes(item.text))\r\n      .join(\"\\n\");\r\n\r\n    await fs.writeFile(filePath, newContent, \"utf-8\");\r\n  } catch (e) {\r\n    console.error(\"Error al eliminar l√≠nea:\", e);\r\n  }\r\n}\r\n\r\n/**\r\n * Agrega la l√≠nea de vuelta al archivo vinculado cuando la tarea se desmarca.\r\n */\r\nexport async function addToLinkedFile(item: TodoItem) {\r\n  if (!item.relativePath) return;\r\n\r\n  const root = vscode.workspace.workspaceFolders?.[0];\r\n  if (!root) return;\r\n\r\n  try {\r\n    const filePath = path.join(root.uri.fsPath, item.relativePath);\r\n\r\n    let content = \"\";\r\n    try {\r\n      content = await fs.readFile(filePath, \"utf-8\");\r\n    } catch {\r\n      // Si no existe, se crear√°\r\n    }\r\n\r\n    // L√≠nea TODO con formato correcto\r\n    const todoLine = `// TODO: ${item.text}`;\r\n\r\n    // Evita duplicados\r\n    if (!content.includes(todoLine)) {\r\n      content += content.length > 0 ? `\\n${todoLine}` : todoLine;\r\n      await fs.writeFile(filePath, content, \"utf-8\");\r\n    }\r\n  } catch (e) {\r\n    console.error(\"Error al agregar l√≠nea TODO al archivo:\", e);\r\n  }\r\n}\r\n","import * as vscode from \"vscode\";\r\nimport type { ChangelogEntry, ChangelogVersion } from \"./types\";\r\nimport { readChangelog } from \"./persistence\";\r\n\r\ntype SectionKey =\r\n  | \"Additions\"\r\n  | \"Changes\"\r\n  | \"Deprecations\"\r\n  | \"Fixes\"\r\n  | \"Removals\"\r\n  | \"Security Changes\";\r\n\r\nconst sections: Array<{ key: SectionKey; label: string }> = [\r\n  { key: \"Additions\", label: \"üÜï Additions\" },\r\n  { key: \"Changes\", label: \"üîÉ Changes\" },\r\n  { key: \"Deprecations\", label: \"‚¨áÔ∏è Deprecations\" },\r\n  { key: \"Fixes\", label: \"üÜó Fixes\" },\r\n  { key: \"Removals\", label: \"üóëÔ∏è Removals\" },\r\n  { key: \"Security Changes\", label: \"üõ°Ô∏è Security Changes\" },\r\n];\r\n\r\ntype VersionNode = {\r\n  kind: \"version\";\r\n  version: string;\r\n  date: string;\r\n  sections: Record<string, ChangelogEntry[]>;\r\n};\r\n\r\ntype SectionNode = {\r\n  kind: \"section\";\r\n  key: SectionKey;      // <- key real\r\n  label: string;        // <- label bonito\r\n  count: number;\r\n  version: VersionNode;\r\n};\r\n\r\ntype EntryNode = {\r\n  kind: \"entry\";\r\n  text: string;\r\n  version: VersionNode;\r\n  section: SectionKey;\r\n};\r\n\r\ntype Node = VersionNode | SectionNode | EntryNode;\r\n\r\nexport class ChangelogProvider implements vscode.TreeDataProvider<Node> {\r\n  private _onDidChange = new vscode.EventEmitter<void>();\r\n  readonly onDidChangeTreeData = this._onDidChange.event;\r\n\r\n  private versions: VersionNode[] = [];\r\n\r\n  constructor() {\r\n    void this.load();\r\n  }\r\n\r\n  async load() {\r\n    const raw = await readChangelog();\r\n\r\n    this.versions = raw.map((v) => ({\r\n      kind: \"version\",\r\n      version: v.version,\r\n      date: v.date,\r\n      sections: v.sections,\r\n    }));\r\n\r\n    this._onDidChange.fire();\r\n  }\r\n\r\n  refresh() {\r\n    void this.load();\r\n  }\r\n\r\n  getTreeItem(element: Node): vscode.TreeItem {\r\n    if (element.kind === \"version\") {\r\n      const label = `${element.version}   ${element.date}`;\r\n      const ti = new vscode.TreeItem(label, vscode.TreeItemCollapsibleState.Collapsed);\r\n      ti.contextValue = \"changelogVersion\";\r\n      return ti;\r\n    }\r\n\r\n    if (element.kind === \"section\") {\r\n      const ti = new vscode.TreeItem(\r\n        `${element.label} (${element.count})`,\r\n        vscode.TreeItemCollapsibleState.Collapsed\r\n      );\r\n      ti.contextValue = \"changelogSection\";\r\n      return ti;\r\n    }\r\n\r\n    // entry\r\n    const ti = new vscode.TreeItem(`üî∏ ${element.text}`, vscode.TreeItemCollapsibleState.None);\r\n    ti.contextValue = \"changelogEntry\";\r\n    return ti;\r\n  }\r\n\r\n  getChildren(element?: Node): Thenable<Node[]> {\r\n    if (!element) {\r\n      return Promise.resolve(\r\n        [...this.versions].sort((a, b) => b.date.localeCompare(a.date))\r\n      );\r\n    }\r\n\r\n    if (element.kind === \"version\") {\r\n      return Promise.resolve(\r\n        sections.map(({ key, label }) => {\r\n          const count = element.sections[key]?.length ?? 0;\r\n\r\n          const node: SectionNode = {\r\n            kind: \"section\",\r\n            key,\r\n            label,\r\n            count,\r\n            version: element,\r\n          };\r\n\r\n          return node;\r\n        })\r\n      );\r\n    }\r\n\r\n    // Section -> entries\r\n    if (element.kind === \"section\") {\r\n      const ver = element.version;\r\n      const list = ver.sections[element.key] ?? [];\r\n\r\n      return Promise.resolve(\r\n        list.map((e) => ({\r\n          kind: \"entry\",\r\n          text: e.text,\r\n          version: ver,\r\n          section: element.key,\r\n        }))\r\n      );\r\n    }\r\n\r\n    return Promise.resolve([]);\r\n  }\r\n}\r\n","import * as vscode from \"vscode\";\r\n\r\nimport type { TodoItem as TodoType } from \"./types\";\r\nimport { TodoProvider } from \"./provider\";\r\n\r\n// Funciones de persistencia\r\nimport { readTodos, writeTodos } from \"./persistence\";\r\n\r\n// Esc√°ner de TODOs en archivos\r\nimport { scanTodosInWorkspace } from \"./scanner\";\r\n\r\nexport function registerTodo(context: vscode.ExtensionContext) {\r\n  const provider = new TodoProvider();\r\n  vscode.window.registerTreeDataProvider(\"todoView\", provider);\r\n\r\n  context.subscriptions.push(\r\n    // Agregar tarea manual\r\n    vscode.commands.registerCommand(\"todo.add\", async () => {\r\n      const text = await vscode.window.showInputBox({\r\n        prompt: \"Add a new task\",\r\n      });\r\n      if (text) {\r\n        await provider.add(text.trim());\r\n      }\r\n    }),\r\n\r\n    // Marcar como completada\r\n    vscode.commands.registerCommand(\r\n      \"todo.complete\",\r\n      (item?: TodoType) => item && provider.complete(item)\r\n    ),\r\n\r\n    // Marcar como incompleta\r\n    vscode.commands.registerCommand(\r\n      \"todo.uncomplete\",\r\n      (item?: TodoType) => item && provider.uncomplete(item)\r\n    ),\r\n\r\n    // Refrescar lista\r\n    vscode.commands.registerCommand(\"todo.refresh\", () => {\r\n      provider.refresh();\r\n    }),\r\n\r\n    // Editar texto de tarea\r\n    vscode.commands.registerCommand(\r\n      \"todo.edit\",\r\n      async (item?: TodoType) => {\r\n        if (!item) return;\r\n\r\n        const text = await vscode.window.showInputBox({\r\n          prompt: \"Edit task\",\r\n          value: item.text,\r\n        });\r\n\r\n        if (text) {\r\n          await provider.edit(item, text.trim());\r\n        }\r\n      }\r\n    ),\r\n\r\n    // Eliminar tarea\r\n    vscode.commands.registerCommand(\r\n      \"todo.remove\",\r\n      async (item?: TodoType) => {\r\n        if (!item) return;\r\n        await provider.remove(item);\r\n      }\r\n    ),\r\n\r\n    // ‚ú® Nuevo: Escanear TODOs dentro de archivos del proyecto\r\n    vscode.commands.registerCommand(\"todo.scanFiles\", async () => {\r\n      try {\r\n        // Busca TODOs en todos los archivos\r\n        const found = await scanTodosInWorkspace();\r\n\r\n        if (found.length === 0) {\r\n          vscode.window.showInformationMessage(\r\n            \"No TODOs found in project files.\"\r\n          );\r\n          return;\r\n        }\r\n\r\n        // Leer tareas existentes\r\n        const existing = await readTodos();\r\n\r\n        // Concatenar (puedes luego hacer deduplicaci√≥n si quieres)\r\n        const combined = [...existing, ...found];\r\n\r\n        // Guardar todo en persistencia\r\n        await writeTodos(combined);\r\n\r\n        // Refrescar lista\r\n        provider.refresh();\r\n\r\n        vscode.window.showInformationMessage(\r\n          `Added ${found.length} TODOs found in project files.`\r\n        );\r\n      } catch (err) {\r\n        console.error(\"Error scanning TODOs:\", err);\r\n        vscode.window.showErrorMessage(\r\n          \"Failed to scan TODOs in project files.\"\r\n        );\r\n      }\r\n    })\r\n  );\r\n}\r\n","import * as vscode from \"vscode\";\r\nimport type { TodoItem } from \"./types\";\r\nimport { readTodos, writeTodos, makeTodo } from \"./persistence\";\r\nimport { removeFromLinkedFile, addToLinkedFile, syncOnRefresh } from \"./fileSync\";\r\n\r\nexport class TodoProvider implements vscode.TreeDataProvider<TodoItem> {\r\n  private _onDidChange = new vscode.EventEmitter<void>();\r\n  readonly onDidChangeTreeData = this._onDidChange.event;\r\n\r\n  private items: TodoItem[] = [];\r\n\r\n  constructor() {\r\n    void this.load();\r\n  }\r\n\r\n  async load() {\r\n    const all = await readTodos();\r\n\r\n    this.items = [\r\n      ...all.filter((t) => !t.completed),\r\n      ...all.filter((t) => t.completed),\r\n    ];\r\n\r\n    this._onDidChange.fire();\r\n  }\r\n\r\n  refresh() {\r\n    syncOnRefresh()\r\n      .then(() => this.load())\r\n      .catch(console.error);\r\n  }\r\n\r\n  getTreeItem(item: TodoItem): vscode.TreeItem {\r\n    // Construir el label con tachado visual si est√° completo\r\n    const text = item.completed\r\n      ? item.text // lo dejamos igual para el label\r\n      : item.text;\r\n\r\n    const treeItem = new vscode.TreeItem(text);\r\n\r\n    // Agregar decoraci√≥n visual para completadas\r\n    if (item.completed) {\r\n      // Usa un icono de check y tooltip\r\n      treeItem.iconPath = new vscode.ThemeIcon(\"check\");\r\n      treeItem.tooltip = `‚úîÔ∏è ${item.text}`;\r\n      treeItem.description = \"completed\";\r\n    }\r\n\r\n    // Si tiene archivo y l√≠nea, permitir abrir\r\n    if (item.relativePath && typeof item.line === \"number\") {\r\n      const root = vscode.workspace.workspaceFolders?.[0];\r\n      if (root) {\r\n        const uri = vscode.Uri.joinPath(root.uri, item.relativePath);\r\n        treeItem.command = {\r\n          command: \"vscode.open\",\r\n          title: \"Open\",\r\n          arguments: [\r\n            uri,\r\n            { selection: new vscode.Range(item.line, 0, item.line, 0) },\r\n          ],\r\n        };\r\n\r\n        // Si no est√° completada, show descripci√≥n de l√≠nea\r\n        if (!item.completed) {\r\n          treeItem.description = `${item.relativePath}:${item.line + 1}`;\r\n        } else {\r\n          // si est√° completada pero a√∫n tiene ruta, mantenemos tambi√©n la info\r\n          treeItem.description += ` (${item.relativePath}:${item.line + 1})`;\r\n        }\r\n      }\r\n    }\r\n\r\n    treeItem.contextValue = item.completed ? \"done\" : \"pending\";\r\n    return treeItem;\r\n  }\r\n\r\n  getChildren(): Thenable<TodoItem[]> {\r\n    return Promise.resolve(this.items);\r\n  }\r\n\r\n  async add(text: string) {\r\n    const todos = await readTodos();\r\n    todos.push(makeTodo(text));\r\n    await writeTodos(todos);\r\n    this.refresh();\r\n  }\r\n\r\n  async addScanned(found: TodoItem[]) {\r\n    if (found.length === 0) return;\r\n\r\n    const existing = await readTodos();\r\n    const map = new Map<string, TodoItem>();\r\n\r\n    for (const t of existing) map.set(t.id, t);\r\n    for (const t of found) if (!map.has(t.id)) map.set(t.id, t);\r\n\r\n    await writeTodos([...map.values()]);\r\n    this.refresh();\r\n  }\r\n\r\n  async edit(item: TodoItem, newText: string): Promise<void> {\r\n    const todos = await readTodos();\r\n    const todo = todos.find((t) => t.id === item.id);\r\n    if (!todo) return;\r\n\r\n    todo.text = newText;\r\n    await writeTodos(todos);\r\n    this.refresh();\r\n  }\r\n\r\n  // Marcar como incompleta\r\n  async uncomplete(item?: TodoItem): Promise<void> {\r\n    if (!item) return;\r\n\r\n    const todos = await readTodos();\r\n    const todo = todos.find((t) => t.id === item.id);\r\n    if (!todo) return;\r\n\r\n    // Marcar como no completada\r\n    todo.completed = false;\r\n    todo.date_finished = null;\r\n    await writeTodos(todos);\r\n\r\n    // Agregar la l√≠nea al archivo vinculado si tiene\r\n    await addToLinkedFile(item);\r\n\r\n    // Refrescar la vista\r\n    this.refresh();\r\n  }\r\n\r\n  async complete(item: TodoItem) {\r\n    const todos = await readTodos();\r\n    const t = todos.find((x) => x.id === item.id);\r\n    if (!t) return;\r\n\r\n    // Marcar como completa\r\n    t.completed = true;\r\n    t.date_finished = new Date().toISOString();\r\n    await writeTodos(todos);\r\n\r\n    // Eliminar la l√≠nea del archivo vinculado si la tiene\r\n    await removeFromLinkedFile(item);\r\n\r\n    // Refrescar la vista\r\n    this.refresh();\r\n  }\r\n\r\n  async remove(item: TodoItem) {\r\n    await writeTodos((await readTodos()).filter((t) => t.id !== item.id));\r\n    this.refresh();\r\n  }\r\n}\r\n","import * as vscode from \"vscode\";\r\nimport { ChangelogProvider } from \"./provider\";\r\nimport { readChangelog, writeChangelog } from \"./persistence\";\r\n\r\nexport function registerChangelog(context: vscode.ExtensionContext) {\r\n  const provider = new ChangelogProvider();\r\n\r\n  const treeReg = vscode.window.registerTreeDataProvider(\"changelogView\", provider);\r\n  context.subscriptions.push(treeReg);\r\n\r\n  context.subscriptions.push(\r\n    vscode.commands.registerCommand(\"changelog.refresh\", () => {\r\n      provider.refresh();\r\n    })\r\n  );\r\n\r\n  context.subscriptions.push(\r\n    vscode.commands.registerCommand(\"changelog.addVersion\", async () => {\r\n      const version = await vscode.window.showInputBox({\r\n        prompt: \"New version (e.g., 1.0.0)\",\r\n      });\r\n      if (!version) return;\r\n\r\n      const date = new Date().toISOString().split(\"T\")[0];\r\n      const all = await readChangelog();\r\n\r\n      const exists = all.some((v) => v.version === version);\r\n      if (exists) {\r\n        vscode.window.showWarningMessage(`Version \"${version}\" already exists!`);\r\n        return;\r\n      }\r\n\r\n      all.unshift({\r\n        version,\r\n        date,\r\n        sections: {\r\n          Additions: [],\r\n          Changes: [],\r\n          Deprecations: [],\r\n          Fixes: [],\r\n          Removals: [],\r\n          \"Security Changes\": [],\r\n        },\r\n      });\r\n\r\n      await writeChangelog(all);\r\n      provider.refresh();\r\n    })\r\n  );\r\n\r\n  context.subscriptions.push(\r\n    vscode.commands.registerCommand(\"changelog.addEntry\", async (node: any) => {\r\n      const versionObj = node.version; \r\n\r\n      const sectionKey: string = node.key ?? node.name;\r\n      const sectionLabel: string = node.label ?? node.name ?? sectionKey;\r\n\r\n      const text = await vscode.window.showInputBox({\r\n        prompt: `Add entry to ${sectionLabel}`,\r\n        placeHolder: \"Describe the change...\",\r\n      });\r\n      if (!text) return;\r\n\r\n      const all = await readChangelog();\r\n      const versionIdx = all.findIndex((v) => v.version === versionObj.version);\r\n      if (versionIdx === -1) return;\r\n\r\n      if (!all[versionIdx].sections[sectionKey]) {\r\n        all[versionIdx].sections[sectionKey] = [];\r\n      }\r\n\r\n      all[versionIdx].sections[sectionKey].push({ text });\r\n\r\n      await writeChangelog(all);\r\n      provider.refresh();\r\n    })\r\n  );\r\n\r\n  context.subscriptions.push(\r\n    vscode.commands.registerCommand(\"changelog.editEntry\", async (node: any) => {\r\n      const newText = await vscode.window.showInputBox({\r\n        prompt: \"Edit entry text\",\r\n        value: node.text,\r\n      });\r\n      if (!newText) return;\r\n\r\n      const all = await readChangelog();\r\n      const versionIdx = all.findIndex((v) => v.version === node.version.version);\r\n      if (versionIdx === -1) return;\r\n\r\n      const secArr = all[versionIdx].sections[node.section] ?? [];\r\n      all[versionIdx].sections[node.section] = secArr;\r\n\r\n      const entryIdx = secArr.findIndex((e: any) => e.text === node.text);\r\n      if (entryIdx === -1) return;\r\n\r\n      secArr[entryIdx].text = newText;\r\n\r\n      await writeChangelog(all);\r\n      provider.refresh();\r\n    })\r\n  );\r\n\r\n  context.subscriptions.push(\r\n    vscode.commands.registerCommand(\"changelog.removeEntry\", async (node: any) => {\r\n      const confirm = await vscode.window.showWarningMessage(\r\n        `Remove this entry?\\n\"${node.text}\"`,\r\n        { modal: true },\r\n        \"Yes\"\r\n      );\r\n      if (confirm !== \"Yes\") return;\r\n\r\n      const all = await readChangelog();\r\n      const versionIdx = all.findIndex((v) => v.version === node.version.version);\r\n      if (versionIdx === -1) return;\r\n\r\n      const secArr = all[versionIdx].sections[node.section] ?? [];\r\n      all[versionIdx].sections[node.section] = secArr.filter((e: any) => e.text !== node.text);\r\n\r\n      await writeChangelog(all);\r\n      provider.refresh();\r\n    })\r\n  );\r\n\r\n  context.subscriptions.push(\r\n    vscode.commands.registerCommand(\"changelog.removeVersion\", async (node: any) => {\r\n      const confirm = await vscode.window.showWarningMessage(\r\n        `Remove version \"${node.version}\" and all its entries?`,\r\n        { modal: true },\r\n        \"Yes\"\r\n      );\r\n      if (confirm !== \"Yes\") return;\r\n\r\n      const all = await readChangelog();\r\n      const filtered = all.filter((v) => v.version !== node.version);\r\n\r\n      await writeChangelog(filtered);\r\n      provider.refresh();\r\n    })\r\n  );\r\n}\r\n","module.exports = require(\"path\");","import * as vscode from \"vscode\";\r\nimport type { TodoItem } from \"./types\";\r\nimport * as crypto from \"crypto\";\r\n\r\nconst FILE_NAME = \"TO-DO.md\";\r\n\r\n/* ---------------- PATH ---------------- */\r\n\r\nfunction getFileUri(): vscode.Uri | null {\r\n  const folders = vscode.workspace.workspaceFolders;\r\n  if (!folders || folders.length === 0) {\r\n    vscode.window.showWarningMessage(\"Open a folder first to save TO-DOs.\");\r\n    return null;\r\n  }\r\n  return vscode.Uri.joinPath(folders[0].uri, FILE_NAME);\r\n}\r\n\r\nfunction normalizePath(p: string): string {\r\n  return p.replace(/\\\\/g, \"/\");\r\n}\r\n\r\n/* ---------------- ID (SCAN) ---------------- */\r\n\r\nfunction makeSourceKey(\r\n  relativePath: string,\r\n  line: number,\r\n  text: string\r\n): string {\r\n  const t = text.trim().slice(0, 32);\r\n  return `${normalizePath(relativePath)}:${line}:${t}`;\r\n}\r\n\r\nfunction hashId(input: string): string {\r\n  return crypto.createHash(\"sha256\").update(input).digest(\"hex\").slice(0, 16);\r\n}\r\n\r\n/* ---------------- FACTORIES ---------------- */\r\n\r\n// üî¥ SOLO para TODOs manuales\r\nexport function makeTodo(text: string): TodoItem {\r\n  return {\r\n    id: crypto.randomUUID(),\r\n    text,\r\n    completed: false,\r\n    date_added: new Date().toISOString(),\r\n    date_finished: null,\r\n  };\r\n}\r\n\r\n// üü¢ SOLO para TODOs escaneados\r\nexport function makeScannedTodo(\r\n  text: string,\r\n  relativePath: string,\r\n  line: number\r\n): TodoItem {\r\n  const cleanText = text.trim() || \"TODO\";\r\n  const sourceKey = makeSourceKey(relativePath, line, cleanText);\r\n  const id = hashId(sourceKey);\r\n\r\n  return {\r\n    id,\r\n    text: cleanText,\r\n    completed: false,\r\n    date_added: new Date().toISOString(),\r\n    date_finished: null,\r\n    relativePath: normalizePath(relativePath),\r\n    line,\r\n    sourceKey,\r\n  };\r\n}\r\n\r\n/* ---------------- READ ---------------- */\r\n\r\nexport async function readTodos(): Promise<TodoItem[]> {\r\n  const uri = getFileUri();\r\n  if (!uri) return [];\r\n\r\n  try {\r\n    const bytes = await vscode.workspace.fs.readFile(uri);\r\n    return parseMarkdown(Buffer.from(bytes).toString(\"utf8\"));\r\n  } catch {\r\n    return [];\r\n  }\r\n}\r\n\r\n/* ---------------- WRITE ---------------- */\r\n\r\nexport async function writeTodos(items: TodoItem[]): Promise<void> {\r\n  const uri = getFileUri();\r\n  if (!uri) return;\r\n\r\n  // üî• blindaje final\r\n  const map = new Map<string, TodoItem>();\r\n  for (const t of items) {\r\n    if (!map.has(t.id)) map.set(t.id, t);\r\n  }\r\n\r\n  const md = generateMarkdown([...map.values()]);\r\n  await vscode.workspace.fs.writeFile(uri, Buffer.from(md, \"utf8\"));\r\n\r\n  await ensureGitignoreHasEntry(FILE_NAME);\r\n}\r\n\r\n/* ---------------- PARSE ---------------- */\r\n\r\nfunction parseMarkdown(md: string): TodoItem[] {\r\n  const todos: TodoItem[] = [];\r\n\r\n  for (const line of md.split(/\\r?\\n/)) {\r\n    const m = line.match(/^- \\[( |x)\\] (.+?)(?: <!-- (.+) -->)?$/);\r\n    if (!m) continue;\r\n\r\n    const completed = m[1] === \"x\";\r\n    const text = m[2];\r\n    const metaRaw = m[3];\r\n\r\n    if (!metaRaw) continue;\r\n\r\n    try {\r\n      const meta = JSON.parse(metaRaw);\r\n\r\n      todos.push({\r\n        id: meta.id,\r\n        text,\r\n        completed,\r\n        date_added: meta.date_added,\r\n        date_finished: meta.date_finished ?? null,\r\n        relativePath: meta.relativePath,\r\n        line: meta.line,\r\n        sourceKey: meta.sourceKey,\r\n      });\r\n    } catch {\r\n      // ignore\r\n    }\r\n  }\r\n\r\n  return todos;\r\n}\r\n\r\n/* ---------------- GENERATE ---------------- */\r\n\r\nfunction generateMarkdown(items: TodoItem[]): string {\r\n  const lines: string[] = [\"# TO-DO\", \"\"];\r\n\r\n  for (const item of items) {\r\n    const meta = {\r\n      id: item.id,\r\n      date_added: item.date_added,\r\n      date_finished: item.date_finished ?? null,\r\n      relativePath: item.relativePath,\r\n      line: item.line,\r\n      sourceKey: item.sourceKey,\r\n    };\r\n\r\n    lines.push(\r\n      `- [${item.completed ? \"x\" : \" \"}] ${item.text} <!-- ${JSON.stringify(\r\n        meta\r\n      )} -->`\r\n    );\r\n  }\r\n\r\n  lines.push(\"\");\r\n  return lines.join(\"\\n\");\r\n}\r\n\r\n/* ---------------- GITIGNORE ---------------- */\r\n\r\nasync function ensureGitignoreHasEntry(fileName: string) {\r\n  const folders = vscode.workspace.workspaceFolders;\r\n  if (!folders || folders.length === 0) return;\r\n\r\n  const gitignoreUri = vscode.Uri.joinPath(folders[0].uri, \".gitignore\");\r\n\r\n  let content = \"\";\r\n  try {\r\n    content = Buffer.from(\r\n      await vscode.workspace.fs.readFile(gitignoreUri)\r\n    ).toString(\"utf8\");\r\n  } catch {}\r\n\r\n  if (!content.split(/\\r?\\n/).includes(fileName)) {\r\n    await vscode.workspace.fs.writeFile(\r\n      gitignoreUri,\r\n      Buffer.from(content + \"\\n\" + fileName + \"\\n\", \"utf8\")\r\n    );\r\n  }\r\n}\r\n","module.exports = require(\"fs/promises\");","module.exports = require(\"crypto\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import * as vscode from \"vscode\";\r\nimport { registerTodo } from \"./todo/index\";\r\nimport { registerChangelog } from \"./changelog/index\";\r\n\r\nexport function activate(context: vscode.ExtensionContext) {\r\n\r\n  registerTodo(context);\r\n\r\n  registerChangelog(context);\r\n\r\n}\r\n\r\nexport function deactivate() {}\r\n"],"names":["async","todos","seen","Set","files","vscode","workspace","findFiles","file","doc","openTextDocument","ws","getWorkspaceFolder","root","uri","fsPath","i","lineCount","text","lineAt","TODO_REGEX","test","match","raw","trim","rel","path","relative","todo","makeScannedTodo","has","id","add","push","getFileUri","bytes","fs","readFile","md","lines","split","versions","current","section","rawLine","line","ver","parseVersionHeading","version","date","sections","emptySections","secName","normalizeSectionHeading","startsWith","parseEntry","parseMd","decoder","decode","sectionOrder","sorted","sort","a","b","byDate","localeCompare","String","undefined","numeric","v","sectionsWithEntries","filter","sec","length","entries","e","join","generateMd","writeFile","encoder","encode","fileName","pop","folders","workspaceFolders","rootUri","gitignoreUri","Uri","joinPath","content","Buffer","from","toString","includes","newContent","ensureGitignoreHasEntry","SECTION_ORDER","window","showWarningMessage","TextDecoder","TextEncoder","obj","sn","m","module","exports","require","readTodos","updated","t","relativePath","completed","filePath","date_finished","Date","toISOString","console","error","writeTodos","item","todoLine","key","label","_onDidChange","EventEmitter","onDidChangeTreeData","this","event","constructor","load","readChangelog","map","kind","fire","refresh","getTreeItem","element","ti","TreeItem","TreeItemCollapsibleState","Collapsed","contextValue","count","None","getChildren","Promise","resolve","list","context","provider","TodoProvider","registerTreeDataProvider","subscriptions","commands","registerCommand","showInputBox","prompt","complete","uncomplete","value","edit","remove","found","scanTodosInWorkspace","showInformationMessage","combined","err","showErrorMessage","items","all","syncOnRefresh","then","catch","treeItem","iconPath","ThemeIcon","tooltip","description","command","title","arguments","selection","Range","makeTodo","addScanned","existing","Map","set","values","newText","find","addToLinkedFile","x","removeFromLinkedFile","ChangelogProvider","treeReg","some","unshift","Additions","Changes","Deprecations","Fixes","Removals","writeChangelog","node","versionObj","sectionKey","name","sectionLabel","placeHolder","versionIdx","findIndex","secArr","entryIdx","modal","filtered","crypto","randomUUID","date_added","cleanText","sourceKey","slice","normalizePath","makeSourceKey","input","createHash","update","digest","metaRaw","meta","JSON","parse","parseMarkdown","stringify","generateMarkdown","FILE_NAME","p","replace","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call","registerTodo","registerChangelog"],"ignoreList":[],"sourceRoot":""}